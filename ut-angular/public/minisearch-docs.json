[
  { "id": 1, "title": "What is MiniSearch?", "text": "MiniSearch is a lightweight, zero-dependency JavaScript library for full-text search. It runs entirely client-side, in-memory, without needing a server or external service. The gzipped bundle is only about 7 kB.", "tags": ["overview", "introduction", "client-side"], "category": "concepts" },
  { "id": 2, "title": "TF-IDF Ranking", "text": "MiniSearch uses TF-IDF (Term Frequency–Inverse Document Frequency) to rank search results by relevance. Terms that appear frequently in a document but rarely across the corpus receive higher scores.", "tags": ["ranking", "relevance", "scoring"], "category": "concepts" },
  { "id": 3, "title": "Inverted Index", "text": "Internally MiniSearch builds an inverted index mapping each term to the documents that contain it. This data structure enables sub-millisecond lookups even for large document sets.", "tags": ["internals", "index", "performance"], "category": "concepts" },
  { "id": 4, "title": "Tokenization", "text": "Tokenization splits text into individual terms. MiniSearch uses a default tokenizer that splits on non-alphanumeric characters, but you can supply a custom tokenizer function for specialized languages or formats.", "tags": ["tokenizer", "text-processing", "customization"], "category": "concepts" },
  { "id": 5, "title": "Term Processing Pipeline", "text": "After tokenization, terms pass through a processing pipeline: lowercasing, optional stemming, and stop-word removal. Each step can be customized or replaced.", "tags": ["stemming", "lowercase", "stop-words"], "category": "concepts" },
  { "id": 6, "title": "Prefix Search", "text": "Prefix search matches documents containing terms that start with the query. It is ideal for autocomplete and typeahead scenarios. Enable it with { prefix: true }.", "tags": ["prefix", "autocomplete", "typeahead"], "category": "concepts" },
  { "id": 7, "title": "Fuzzy Search", "text": "Fuzzy search tolerates typos by allowing a configurable edit distance (Levenshtein). Set { fuzzy: 0.2 } to allow up to 20 % of the term length as edits.", "tags": ["fuzzy", "typo-tolerance", "levenshtein"], "category": "concepts" },
  { "id": 8, "title": "Field Boosting", "text": "Boosting assigns different weights to indexed fields. For example, boost: { title: 2 } makes matches in the title count twice as much as matches in other fields.", "tags": ["boosting", "weights", "relevance"], "category": "concepts" },
  { "id": 9, "title": "Filtering Results", "text": "You can filter search results with a callback function. The filter receives each result object and returns true to include it. This is useful for faceted search or category filtering.", "tags": ["filter", "facets", "callback"], "category": "concepts" },
  { "id": 10, "title": "Auto-Suggest", "text": "The autoSuggest method returns weighted suggestions based on partial input. It combines prefix matching with ranking to produce the most likely completions.", "tags": ["autosuggest", "suggestions", "completions"], "category": "concepts" },
  { "id": 11, "title": "Combine Strategies (AND / OR)", "text": "By default MiniSearch combines multiple query terms with OR. Set { combineWith: 'AND' } to require all terms to be present in a document.", "tags": ["combine", "boolean", "AND", "OR"], "category": "concepts" },
  { "id": 12, "title": "Incremental Indexing", "text": "Unlike some libraries that require a full rebuild, MiniSearch supports adding and removing documents at runtime via add(), remove(), discard(), and replace() methods.", "tags": ["incremental", "runtime", "dynamic"], "category": "concepts" },
  { "id": 13, "title": "Serialization", "text": "You can serialize the entire index with JSON.stringify(miniSearch) and restore it with MiniSearch.loadJSON(). This enables build-time indexing and instant search on page load.", "tags": ["serialization", "json", "build-time"], "category": "concepts" },
  { "id": 14, "title": "Zero Dependencies", "text": "MiniSearch has no runtime dependencies. The entire library is self-contained, keeping your bundle small and free from transitive dependency risks.", "tags": ["dependencies", "bundle-size", "lightweight"], "category": "concepts" },
  { "id": 15, "title": "TypeScript Support", "text": "MiniSearch ships with native TypeScript type declarations. You get full IntelliSense, type checking on options and results, and generic document types.", "tags": ["typescript", "types", "intellisense"], "category": "concepts" },
  { "id": 16, "title": "Browser and Node.js", "text": "MiniSearch works in any JavaScript environment: modern browsers, Node.js, Deno, and web workers. There are no DOM or platform-specific dependencies.", "tags": ["browser", "node", "universal"], "category": "concepts" },
  { "id": 17, "title": "Score Explanation", "text": "Each search result includes a score property (a floating-point number) and a match object showing which fields and terms matched. Use these for debugging relevance.", "tags": ["score", "match", "debugging"], "category": "concepts" },
  { "id": 18, "title": "Multi-field Indexing", "text": "Index multiple fields (e.g. title, text, tags) simultaneously. Each field gets its own weight in the ranking and can be individually targeted in queries.", "tags": ["multi-field", "fields", "indexing"], "category": "concepts" },
  { "id": 19, "title": "Store Fields", "text": "The storeFields option specifies which fields to include in search results. Only stored fields appear in the result objects, keeping memory usage efficient.", "tags": ["storeFields", "memory", "results"], "category": "concepts" },
  { "id": 20, "title": "Custom Tokenizer", "text": "Replace the default tokenizer by passing a tokenize function in options. This is useful for CJK languages, camelCase splitting, or domain-specific tokenization.", "tags": ["tokenizer", "custom", "CJK"], "category": "concepts" },
  { "id": 21, "title": "Stop Words", "text": "Stop words are common terms (like 'the', 'is', 'at') that add noise to search results. MiniSearch does not remove stop words by default, but you can add a custom processTerm function to filter them.", "tags": ["stop-words", "noise", "processTerm"], "category": "concepts" },
  { "id": 22, "title": "Stemming", "text": "Stemming reduces words to their root form (e.g. 'running' → 'run'). MiniSearch does not include a stemmer by default, but you can plug one in via the processTerm option.", "tags": ["stemming", "root-form", "processTerm"], "category": "concepts" },
  { "id": 23, "title": "Memory Footprint", "text": "The inverted index is compact. For typical datasets (hundreds to low thousands of documents), memory usage stays well under 10 MB, making it suitable for mobile browsers.", "tags": ["memory", "footprint", "mobile"], "category": "concepts" },
  { "id": 24, "title": "Search Performance", "text": "Search queries typically complete in under 1 ms for datasets up to a few thousand documents. Performance scales roughly linearly with corpus size.", "tags": ["performance", "speed", "latency"], "category": "concepts" },
  { "id": 25, "title": "Index Performance", "text": "Indexing 1 000 documents usually takes under 100 ms. For very large datasets consider indexing in a web worker or at build time.", "tags": ["indexing", "build-time", "web-worker"], "category": "concepts" },

  { "id": 26, "title": "new MiniSearch(options)", "text": "Creates a new MiniSearch instance. Required option: fields (array of field names to index). Optional: storeFields, idField, tokenize, processTerm, searchOptions.", "tags": ["constructor", "options", "initialization"], "category": "api" },
  { "id": 27, "title": "miniSearch.add(document)", "text": "Adds a single document to the index. The document must have a unique ID field (default: 'id') and the fields specified in the constructor.", "tags": ["add", "document", "index"], "category": "api" },
  { "id": 28, "title": "miniSearch.addAll(documents)", "text": "Adds an array of documents to the index in bulk. More efficient than calling add() in a loop because it batches internal updates.", "tags": ["addAll", "bulk", "batch"], "category": "api" },
  { "id": 29, "title": "miniSearch.search(query, options?)", "text": "Performs a full-text search and returns an array of results sorted by relevance score. Options: prefix, fuzzy, boost, filter, combineWith, fields.", "tags": ["search", "query", "results"], "category": "api" },
  { "id": 30, "title": "miniSearch.autoSuggest(query, options?)", "text": "Returns an array of { suggestion, score } objects based on partial input. Useful for building autocomplete dropdowns. Accepts the same options as search().", "tags": ["autoSuggest", "autocomplete", "dropdown"], "category": "api" },
  { "id": 31, "title": "miniSearch.remove(document)", "text": "Removes a previously indexed document from the index. The document must match the original (same ID and fields).", "tags": ["remove", "delete", "document"], "category": "api" },
  { "id": 32, "title": "miniSearch.discard(id)", "text": "Soft-deletes a document by its ID without needing the original document object. Slightly less efficient than remove() but more convenient.", "tags": ["discard", "soft-delete", "id"], "category": "api" },
  { "id": 33, "title": "miniSearch.replace(document)", "text": "Replaces a document in the index. Equivalent to remove() followed by add() but done atomically. The new document must have the same ID.", "tags": ["replace", "update", "atomic"], "category": "api" },
  { "id": 34, "title": "MiniSearch.loadJSON(json, options)", "text": "Static method that restores a MiniSearch instance from a JSON string. The options must match the original constructor options (fields, storeFields, etc.).", "tags": ["loadJSON", "deserialize", "static"], "category": "api" },
  { "id": 35, "title": "JSON.stringify(miniSearch)", "text": "Serializes the entire index to a JSON string. The output can be saved to a file or sent to the client for instant restore with loadJSON().", "tags": ["stringify", "serialize", "export"], "category": "api" },
  { "id": 36, "title": "Search Option: prefix", "text": "When prefix is true, each query term is treated as a prefix. 'ang' matches 'angular', 'angularjs', etc. Can be a boolean or a function (term, i, terms) => boolean.", "tags": ["prefix", "option", "boolean"], "category": "api" },
  { "id": 37, "title": "Search Option: fuzzy", "text": "Controls typo tolerance. A number between 0 and 1 sets the maximum edit distance as a fraction of the term length. 0.2 means up to 20 % of characters can differ.", "tags": ["fuzzy", "option", "edit-distance"], "category": "api" },
  { "id": 38, "title": "Search Option: boost", "text": "An object mapping field names to numeric boost factors. { title: 2, tags: 1.5 } makes title matches twice as important and tag matches 1.5 × as important.", "tags": ["boost", "option", "weight"], "category": "api" },
  { "id": 39, "title": "Search Option: filter", "text": "A callback (result) => boolean that filters results after scoring. Useful for category facets, date ranges, or any client-side filtering logic.", "tags": ["filter", "option", "callback"], "category": "api" },
  { "id": 40, "title": "Search Option: combineWith", "text": "Set to 'AND' to require all query terms in a document. Default is 'OR'. Can also be 'AND_NOT' for exclusion queries.", "tags": ["combineWith", "AND", "OR"], "category": "api" },
  { "id": 41, "title": "Search Option: fields", "text": "An array of field names to search in. By default all indexed fields are searched. Use this to restrict search to specific fields.", "tags": ["fields", "option", "restrict"], "category": "api" },
  { "id": 42, "title": "Constructor Option: idField", "text": "The name of the unique identifier field. Defaults to 'id'. Set this if your documents use a different key like '_id' or 'uuid'.", "tags": ["idField", "constructor", "identifier"], "category": "api" },
  { "id": 43, "title": "Constructor Option: tokenize", "text": "A custom tokenizer function (text, fieldName) => string[]. Called during both indexing and searching. Replaces the default whitespace/punctuation tokenizer.", "tags": ["tokenize", "constructor", "custom"], "category": "api" },
  { "id": 44, "title": "Constructor Option: processTerm", "text": "A function (term, fieldName) => string | null. Applied after tokenization to each term. Return null to exclude the term (useful for stop words).", "tags": ["processTerm", "constructor", "pipeline"], "category": "api" },
  { "id": 45, "title": "Constructor Option: storeFields", "text": "Array of field names to include in search results. These fields are stored alongside the index and returned in each result object.", "tags": ["storeFields", "constructor", "results"], "category": "api" },
  { "id": 46, "title": "Constructor Option: fields", "text": "Required. Array of field names to index for search. These fields are tokenized and added to the inverted index.", "tags": ["fields", "constructor", "required"], "category": "api" },
  { "id": 47, "title": "Result Object Properties", "text": "Each search result has: id (document ID), score (relevance), match (object of matched terms/fields), and any fields listed in storeFields.", "tags": ["result", "score", "match"], "category": "api" },
  { "id": 48, "title": "miniSearch.documentCount", "text": "A read-only property that returns the number of documents currently in the index. Useful for UI display or health checks.", "tags": ["documentCount", "property", "count"], "category": "api" },
  { "id": 49, "title": "miniSearch.termCount", "text": "Returns the number of unique terms in the index. Helpful for understanding the vocabulary size and index complexity.", "tags": ["termCount", "property", "vocabulary"], "category": "api" },
  { "id": 50, "title": "Search Option: maxFuzzy", "text": "Limits the maximum absolute edit distance for fuzzy matching. By default there is no hard cap beyond the fractional fuzzy setting. Set maxFuzzy: 3 to cap edits.", "tags": ["maxFuzzy", "option", "limit"], "category": "api" },

  { "id": 51, "title": "Basic Search Example", "text": "const ms = new MiniSearch({ fields: ['title', 'text'] });\nms.addAll(documents);\nconst results = ms.search('angular');\nconsole.log(results);", "tags": ["basic", "search", "quickstart"], "category": "examples" },
  { "id": 52, "title": "Fuzzy Search Example", "text": "// Tolerate typos up to 20% of term length\nconst results = ms.search('anglar', { fuzzy: 0.2 });\n// Still finds 'angular' documents", "tags": ["fuzzy", "typo", "example"], "category": "examples" },
  { "id": 53, "title": "Prefix Search Example", "text": "// Autocomplete: find all terms starting with 'ang'\nconst results = ms.search('ang', { prefix: true });\n// Matches: angular, angularjs, angle, etc.", "tags": ["prefix", "autocomplete", "example"], "category": "examples" },
  { "id": 54, "title": "Boosting Fields Example", "text": "// Make title matches 2x more important\nconst results = ms.search('framework', {\n  boost: { title: 2 }\n});\n// Title matches score higher", "tags": ["boost", "fields", "example"], "category": "examples" },
  { "id": 55, "title": "Filter by Category Example", "text": "const results = ms.search('search', {\n  filter: (result) => result.category === 'frontend'\n});\n// Only returns results in 'frontend' category", "tags": ["filter", "category", "example"], "category": "examples" },
  { "id": 56, "title": "Auto-Suggest Example", "text": "const suggestions = ms.autoSuggest('rea', { prefix: true });\n// Returns: [{ suggestion: 'react', score: 5.2 }, { suggestion: 'read', score: 2.1 }]", "tags": ["autosuggest", "autocomplete", "example"], "category": "examples" },
  { "id": 57, "title": "AND Combination Example", "text": "// Require ALL terms to match\nconst results = ms.search('angular framework', {\n  combineWith: 'AND'\n});\n// Only documents containing both 'angular' AND 'framework'", "tags": ["AND", "combine", "example"], "category": "examples" },
  { "id": 58, "title": "Custom Tokenizer Example", "text": "const ms = new MiniSearch({\n  fields: ['title'],\n  tokenize: (text) => text.split(/[\\s-_]+/)\n});\n// Splits on spaces, hyphens, and underscores", "tags": ["tokenizer", "custom", "example"], "category": "examples" },
  { "id": 59, "title": "Stop Words Example", "text": "const stopWords = new Set(['the', 'is', 'at', 'of', 'a']);\nconst ms = new MiniSearch({\n  fields: ['text'],\n  processTerm: (term) => stopWords.has(term) ? null : term\n});", "tags": ["stop-words", "processTerm", "example"], "category": "examples" },
  { "id": 60, "title": "Stemming Example", "text": "import { stem } from 'some-stemmer';\nconst ms = new MiniSearch({\n  fields: ['text'],\n  processTerm: (term) => stem(term.toLowerCase())\n});\n// 'running' and 'run' now match", "tags": ["stemming", "processTerm", "example"], "category": "examples" },
  { "id": 61, "title": "Highlight Matches Example", "text": "const results = ms.search('angular');\nresults.forEach(r => {\n  Object.entries(r.match).forEach(([term, fields]) => {\n    console.log(`Term '${term}' matched in fields: ${fields}`);\n  });\n});", "tags": ["highlight", "match", "example"], "category": "examples" },
  { "id": 62, "title": "Serialize Index Example", "text": "// Save index to JSON\nconst json = JSON.stringify(ms);\nlocalStorage.setItem('searchIndex', json);\n\n// Restore later\nconst restored = MiniSearch.loadJSON(json, { fields: ['title', 'text'] });", "tags": ["serialize", "loadJSON", "example"], "category": "examples" },
  { "id": 63, "title": "Dynamic Add/Remove Example", "text": "// Add a new document at runtime\nms.add({ id: 999, title: 'New Doc', text: 'Fresh content' });\n\n// Remove it later\nms.remove({ id: 999, title: 'New Doc', text: 'Fresh content' });", "tags": ["dynamic", "add", "remove"], "category": "examples" },
  { "id": 64, "title": "Discard by ID Example", "text": "// Soft-delete without the original document\nms.discard(42);\n// Document 42 is excluded from future searches", "tags": ["discard", "soft-delete", "example"], "category": "examples" },
  { "id": 65, "title": "Replace Document Example", "text": "// Atomically update a document\nms.replace({ id: 1, title: 'Updated Title', text: 'Updated text content' });\n// Old version removed, new version indexed", "tags": ["replace", "update", "example"], "category": "examples" },
  { "id": 66, "title": "Multi-field Search Example", "text": "const ms = new MiniSearch({\n  fields: ['title', 'text', 'tags'],\n  storeFields: ['title', 'category']\n});\nms.addAll(docs);\nconst results = ms.search('router');", "tags": ["multi-field", "storeFields", "example"], "category": "examples" },
  { "id": 67, "title": "Search Specific Fields Example", "text": "// Search only in the title field\nconst results = ms.search('angular', {\n  fields: ['title']\n});\n// Ignores matches in 'text' or 'tags'", "tags": ["fields", "restrict", "example"], "category": "examples" },
  { "id": 68, "title": "Combined Fuzzy + Prefix Example", "text": "// Enable both fuzzy and prefix for a forgiving search\nconst results = ms.search('ang', {\n  prefix: true,\n  fuzzy: 0.2\n});\n// Matches 'angular' even with typos and partial input", "tags": ["fuzzy", "prefix", "combined"], "category": "examples" },
  { "id": 69, "title": "Weighted Multi-field Example", "text": "const results = ms.search('search engine', {\n  boost: { title: 3, tags: 2, text: 1 },\n  combineWith: 'AND'\n});\n// Title matches are 3x more important", "tags": ["boost", "multi-field", "weighted"], "category": "examples" },
  { "id": 70, "title": "Angular Service Integration", "text": "import { Injectable, signal } from '@angular/core';\nimport MiniSearch from 'minisearch';\n\n@Injectable({ providedIn: 'root' })\nexport class SearchService {\n  private ms = new MiniSearch({ fields: ['title', 'text'] });\n  results = signal([]);\n  search(query: string) { this.results.set(this.ms.search(query)); }\n}", "tags": ["angular", "service", "integration"], "category": "examples" },
  { "id": 71, "title": "Debounced Search Input", "text": "import { Subject, debounceTime } from 'rxjs';\n\nconst query$ = new Subject<string>();\nquery$.pipe(debounceTime(200)).subscribe(q => {\n  const results = ms.search(q, { prefix: true, fuzzy: 0.2 });\n  console.log(results);\n});", "tags": ["debounce", "rxjs", "input"], "category": "examples" },
  { "id": 72, "title": "Build-time Indexing", "text": "// build-index.mjs (Node.js script)\nimport MiniSearch from 'minisearch';\nimport { readFileSync, writeFileSync } from 'fs';\n\nconst docs = JSON.parse(readFileSync('docs.json'));\nconst ms = new MiniSearch({ fields: ['title', 'text'] });\nms.addAll(docs);\nwriteFileSync('search-index.json', JSON.stringify(ms));", "tags": ["build-time", "node", "script"], "category": "examples" },
  { "id": 73, "title": "Web Worker Indexing", "text": "// worker.ts\nimport MiniSearch from 'minisearch';\nself.onmessage = (e) => {\n  const ms = new MiniSearch({ fields: ['title', 'text'] });\n  ms.addAll(e.data);\n  self.postMessage(JSON.stringify(ms));\n};", "tags": ["web-worker", "offload", "example"], "category": "examples" },
  { "id": 74, "title": "React Integration Example", "text": "import { useState, useMemo } from 'react';\nimport MiniSearch from 'minisearch';\n\nfunction Search({ docs }) {\n  const ms = useMemo(() => {\n    const m = new MiniSearch({ fields: ['title', 'text'] });\n    m.addAll(docs);\n    return m;\n  }, [docs]);\n  const [results, setResults] = useState([]);\n  return <input onChange={e => setResults(ms.search(e.target.value))} />;\n}", "tags": ["react", "integration", "hooks"], "category": "examples" },
  { "id": 75, "title": "Vue Integration Example", "text": "import MiniSearch from 'minisearch';\nimport { ref, computed } from 'vue';\n\nconst query = ref('');\nconst ms = new MiniSearch({ fields: ['title', 'text'] });\nms.addAll(docs);\nconst results = computed(() =>\n  query.value ? ms.search(query.value) : []\n);", "tags": ["vue", "integration", "reactive"], "category": "examples" },

  { "id": 76, "title": "Documentation Search", "text": "MiniSearch powers search in documentation tools like VitePress and Docusaurus. It indexes docs at build time, serializes the index, and loads it instantly on page load for offline-capable search.", "tags": ["docs", "vitepress", "docusaurus"], "category": "use-cases" },
  { "id": 77, "title": "Autocomplete in Forms", "text": "Use MiniSearch to provide instant suggestions as users type in form fields. Prefix search combined with autoSuggest gives a responsive autocomplete experience without server calls.", "tags": ["autocomplete", "forms", "typeahead"], "category": "use-cases" },
  { "id": 78, "title": "Client-side Table Filtering", "text": "Replace simple string matching in data tables with MiniSearch for relevance-ranked, typo-tolerant filtering. Users can find rows even with imprecise queries.", "tags": ["table", "filtering", "data-grid"], "category": "use-cases" },
  { "id": 79, "title": "Offline / PWA Search", "text": "Progressive Web Apps and offline-first applications benefit from MiniSearch because no network request is needed. Index data once and search locally, even without connectivity.", "tags": ["offline", "pwa", "no-network"], "category": "use-cases" },
  { "id": 80, "title": "Rapid Prototyping", "text": "Instead of setting up Elasticsearch or Algolia for a prototype, drop in MiniSearch for instant full-text search. When the project grows, you can migrate to a server-based solution.", "tags": ["prototype", "quick-start", "mvp"], "category": "use-cases" },
  { "id": 81, "title": "E-commerce Product Search", "text": "For small to medium product catalogs, MiniSearch provides fast, typo-tolerant search with field boosting. Boost product names and brands over descriptions for better results.", "tags": ["e-commerce", "products", "catalog"], "category": "use-cases" },
  { "id": 82, "title": "Knowledge Base / FAQ", "text": "Index FAQ entries and knowledge base articles with MiniSearch. Users find answers instantly with fuzzy matching, even when they misspell technical terms.", "tags": ["faq", "knowledge-base", "help"], "category": "use-cases" },
  { "id": 83, "title": "Blog / CMS Search", "text": "Static site generators can use MiniSearch to add search to blogs and CMS-generated sites. Build the index at deploy time and serve it as a static JSON file.", "tags": ["blog", "cms", "static-site"], "category": "use-cases" },
  { "id": 84, "title": "Chat / Message Search", "text": "Index chat messages or email threads with MiniSearch for quick local search. Incremental indexing means new messages are searchable immediately.", "tags": ["chat", "messages", "incremental"], "category": "use-cases" },
  { "id": 85, "title": "Code Snippet Search", "text": "Build a searchable library of code snippets. Index by language, description, and tags. Fuzzy search helps find snippets even when you cannot remember the exact function name.", "tags": ["code", "snippets", "developer-tools"], "category": "use-cases" },
  { "id": 86, "title": "Recipe Finder", "text": "Index recipes by name, ingredients, and cuisine. Users search 'chicken pasta' and get relevant recipes ranked by how well they match, with filtering by dietary preferences.", "tags": ["recipes", "food", "hobby"], "category": "use-cases" },
  { "id": 87, "title": "Music / Media Library", "text": "Search through a music library by artist, album, song title, and genre. Prefix search powers instant typeahead as users type song names.", "tags": ["music", "media", "library"], "category": "use-cases" },
  { "id": 88, "title": "Address Book Search", "text": "Index contacts by name, email, phone, and company. Fuzzy search handles misspellings of names, and prefix search enables quick lookup.", "tags": ["contacts", "address-book", "people"], "category": "use-cases" },
  { "id": 89, "title": "Log Viewer / Debugger", "text": "Index application logs or error messages for quick search during debugging. Field boosting on severity level helps surface critical errors first.", "tags": ["logs", "debugging", "errors"], "category": "use-cases" },
  { "id": 90, "title": "Bookmark Manager", "text": "Index bookmarks with their titles, URLs, and tags. MiniSearch lets you find saved links instantly, even from partial or misspelled queries.", "tags": ["bookmarks", "urls", "organization"], "category": "use-cases" },
  { "id": 91, "title": "Survey / Poll Results", "text": "Index free-text survey responses for qualitative analysis. Search for themes and keywords across hundreds of responses without manual reading.", "tags": ["survey", "responses", "analysis"], "category": "use-cases" },
  { "id": 92, "title": "Glossary / Dictionary", "text": "Build a searchable glossary or technical dictionary. Prefix search handles partial terms, and fuzzy search catches misspellings of specialized vocabulary.", "tags": ["glossary", "dictionary", "terms"], "category": "use-cases" },
  { "id": 93, "title": "File Explorer Search", "text": "Index file names and metadata for a client-side file browser. MiniSearch is fast enough to search thousands of file entries in real time.", "tags": ["files", "explorer", "metadata"], "category": "use-cases" },
  { "id": 94, "title": "Inventory Management", "text": "Search through inventory items by SKU, name, description, and location. Filter by warehouse or category for targeted results.", "tags": ["inventory", "warehouse", "sku"], "category": "use-cases" },
  { "id": 95, "title": "Educational Quiz App", "text": "Index quiz questions and learning materials. Students search for topics and find related questions, flashcards, and study notes.", "tags": ["education", "quiz", "learning"], "category": "use-cases" },
  { "id": 96, "title": "VitePress Integration", "text": "VitePress uses MiniSearch as its default search provider. It indexes all markdown content at build time and provides instant, offline-capable search out of the box.", "tags": ["vitepress", "vue", "docs"], "category": "use-cases" },
  { "id": 97, "title": "Comparison: MiniSearch vs Lunr.js", "text": "Lunr.js is similar in size (~8 kB) and supports TF-IDF ranking, but lacks incremental indexing and auto-suggest. MiniSearch offers runtime add/remove and a built-in autoSuggest API.", "tags": ["comparison", "lunr", "alternatives"], "category": "use-cases" },
  { "id": 98, "title": "Comparison: MiniSearch vs Fuse.js", "text": "Fuse.js (~5 kB) focuses on fuzzy matching without full-text search features. It lacks prefix search, TF-IDF ranking, and auto-suggest. MiniSearch provides a more complete search experience.", "tags": ["comparison", "fuse", "alternatives"], "category": "use-cases" },
  { "id": 99, "title": "Comparison: MiniSearch vs FlexSearch", "text": "FlexSearch (~6 kB) is very fast but has partial TypeScript support and no built-in auto-suggest. MiniSearch offers native TypeScript, auto-suggest, and a simpler API.", "tags": ["comparison", "flexsearch", "alternatives"], "category": "use-cases" },
  { "id": 100, "title": "Comparison: MiniSearch vs Elasticsearch", "text": "Elasticsearch is a powerful server-side engine for massive datasets. MiniSearch is for client-side search of smaller datasets (up to tens of thousands of documents) without server infrastructure.", "tags": ["comparison", "elasticsearch", "server"], "category": "use-cases" },

  { "id": 101, "title": "Index Creation Options", "text": "When creating a new MiniSearch instance, the options object controls all behavior: which fields to index, how to tokenize, how to process terms, what to store, and default search behavior.", "tags": ["options", "configuration", "setup"], "category": "api" },
  { "id": 102, "title": "Default Search Options", "text": "Set searchOptions in the constructor to apply defaults to every search call. Individual search() calls can override these defaults. Example: searchOptions: { prefix: true, fuzzy: 0.2 }.", "tags": ["searchOptions", "defaults", "constructor"], "category": "api" },
  { "id": 103, "title": "Auto-Suggest Options", "text": "autoSuggest() accepts the same options as search(), plus: suggest (boolean, default true). It groups matching terms and returns them as ranked suggestions.", "tags": ["autoSuggest", "options", "grouping"], "category": "api" },
  { "id": 104, "title": "miniSearch.has(id)", "text": "Returns true if a document with the given ID is currently in the index. Useful for checking before add or remove operations.", "tags": ["has", "check", "existence"], "category": "api" },
  { "id": 105, "title": "miniSearch.getStoredFields(id)", "text": "Returns the stored fields for a document by its ID, or undefined if the document is not in the index. Only returns fields listed in storeFields.", "tags": ["getStoredFields", "lookup", "stored"], "category": "api" },

  { "id": 106, "title": "Faceted Search Pattern", "text": "Combine MiniSearch search with client-side aggregation to build faceted search. After searching, group results by a field (e.g. category) and count occurrences for facet display.\n\nconst results = ms.search(query);\nconst facets = {};\nresults.forEach(r => { facets[r.category] = (facets[r.category] || 0) + 1; });", "tags": ["facets", "aggregation", "pattern"], "category": "examples" },
  { "id": 107, "title": "Paginated Results", "text": "MiniSearch returns all matching results. Implement pagination by slicing the results array:\n\nconst page = 1;\nconst pageSize = 10;\nconst paged = results.slice((page - 1) * pageSize, page * pageSize);", "tags": ["pagination", "slicing", "ui"], "category": "examples" },
  { "id": 108, "title": "Score Normalization", "text": "Normalize scores to a 0-100 range for display:\n\nconst maxScore = Math.max(...results.map(r => r.score));\nconst normalized = results.map(r => ({ ...r, pct: Math.round(r.score / maxScore * 100) }));", "tags": ["score", "normalization", "display"], "category": "examples" },
  { "id": 109, "title": "Empty Query Handling", "text": "When the query is empty, return all documents or a curated list instead of calling search(). MiniSearch returns an empty array for empty queries.\n\nif (!query.trim()) { return allDocs; }\nreturn ms.search(query);", "tags": ["empty", "fallback", "edge-case"], "category": "examples" },
  { "id": 110, "title": "Highlight Utility Function", "text": "function highlight(text: string, terms: string[]): string {\n  const re = new RegExp(`(${terms.join('|')})`, 'gi');\n  return text.replace(re, '<mark>$1</mark>');\n}\n// Use with result.match keys for visual highlighting", "tags": ["highlight", "utility", "markup"], "category": "examples" },

  { "id": 111, "title": "Indexing Speed Benchmark", "text": "Benchmark: indexing 1 000 documents with 3 fields takes ~50-100 ms on modern hardware. For 10 000 documents, expect ~500 ms to 1 s. Consider build-time indexing for larger sets.", "tags": ["benchmark", "speed", "indexing"], "category": "concepts" },
  { "id": 112, "title": "Search Speed Benchmark", "text": "Benchmark: searching 10 000 documents with prefix and fuzzy enabled completes in ~2-5 ms. Without fuzzy, results are sub-millisecond. Real-world latency depends on query complexity.", "tags": ["benchmark", "search", "latency"], "category": "concepts" },
  { "id": 113, "title": "Bundle Size Analysis", "text": "MiniSearch adds ~7 kB gzipped to your bundle. By comparison: Fuse.js is ~5 kB, Lunr.js is ~8 kB, FlexSearch is ~6 kB. All are small enough for most web applications.", "tags": ["bundle", "size", "gzip"], "category": "concepts" },
  { "id": 114, "title": "When NOT to Use MiniSearch", "text": "MiniSearch is not ideal for: datasets over 100 000 documents (consider a server-side engine), real-time multi-user search (use a database), or geospatial queries (use a specialized tool).", "tags": ["limitations", "alternatives", "scale"], "category": "concepts" },
  { "id": 115, "title": "Document ID Uniqueness", "text": "Every document must have a unique ID. Adding a document with a duplicate ID throws an error. Use discard() + add() or replace() to update existing documents.", "tags": ["id", "unique", "constraint"], "category": "concepts" },

  { "id": 116, "title": "Filtering + Boosting Combined", "text": "const results = ms.search('javascript', {\n  filter: r => r.category === 'frontend',\n  boost: { title: 3 }\n});\n// Only frontend results, title matches boosted 3x", "tags": ["filter", "boost", "combined"], "category": "examples" },
  { "id": 117, "title": "Dynamic Facet Counts", "text": "function getFacetCounts(results: any[], field: string): Record<string, number> {\n  return results.reduce((acc, r) => {\n    acc[r[field]] = (acc[r[field]] || 0) + 1;\n    return acc;\n  }, {} as Record<string, number>);\n}", "tags": ["facets", "dynamic", "utility"], "category": "examples" },
  { "id": 118, "title": "Search with Minimum Score", "text": "// Filter out low-relevance results\nconst threshold = 1.0;\nconst results = ms.search(query).filter(r => r.score >= threshold);", "tags": ["score", "threshold", "filtering"], "category": "examples" },
  { "id": 119, "title": "Tag-based Filtering Example", "text": "const results = ms.search('search', {\n  filter: (r) => r.tags?.includes('typescript')\n});\n// Only results tagged with 'typescript'", "tags": ["tags", "filter", "array"], "category": "examples" },
  { "id": 120, "title": "Multiple Category Filter", "text": "const categories = new Set(['api', 'examples']);\nconst results = ms.search('search', {\n  filter: (r) => categories.has(r.category)\n});\n// Results from 'api' or 'examples' only", "tags": ["filter", "multiple", "set"], "category": "examples" },

  { "id": 121, "title": "Event-driven Architecture", "text": "Build event-driven search by wrapping MiniSearch in a service that emits events on index changes. Components subscribe to search results and re-render automatically.", "tags": ["events", "architecture", "reactive"], "category": "use-cases" },
  { "id": 122, "title": "Feature Flag Search", "text": "Index feature flags by name, description, and owner. Teams can search for flags during debugging or auditing without scrolling through long lists.", "tags": ["feature-flags", "devops", "audit"], "category": "use-cases" },
  { "id": 123, "title": "API Endpoint Discovery", "text": "Index API endpoints with their paths, methods, and descriptions. Developers search for the endpoint they need without browsing through Swagger/OpenAPI docs manually.", "tags": ["api", "discovery", "swagger"], "category": "use-cases" },
  { "id": 124, "title": "Help Desk / Ticket Search", "text": "Index support tickets for agent-side search. Fuzzy matching helps find related tickets even when customers describe issues differently each time.", "tags": ["help-desk", "tickets", "support"], "category": "use-cases" },
  { "id": 125, "title": "Real-time Collaboration", "text": "In collaborative editors, MiniSearch can index shared documents for quick find-and-navigate. Incremental indexing keeps the search in sync as content changes.", "tags": ["collaboration", "editor", "realtime"], "category": "use-cases" },

  { "id": 126, "title": "Constructor Option: extractField", "text": "A function (document, fieldName) => string that extracts a field value from a document. Useful when fields are nested or need transformation before indexing.", "tags": ["extractField", "nested", "transform"], "category": "api" },
  { "id": 127, "title": "miniSearch.toJSON()", "text": "Returns the serializable representation of the index. Called implicitly by JSON.stringify(). Equivalent to the internal state needed for loadJSON() restoration.", "tags": ["toJSON", "serialize", "method"], "category": "api" },
  { "id": 128, "title": "Constructor Option: logger", "text": "Pass a logger function (level, message, code) to receive warnings about deprecated options or usage issues. Helpful during development for catching configuration mistakes.", "tags": ["logger", "warnings", "debug"], "category": "api" },

  { "id": 129, "title": "Nested Field Extraction", "text": "const ms = new MiniSearch({\n  fields: ['title', 'author.name'],\n  extractField: (doc, field) => {\n    return field.split('.').reduce((obj, key) => obj?.[key], doc);\n  }\n});\n// Indexes nested 'author.name' field", "tags": ["nested", "extractField", "example"], "category": "examples" },
  { "id": 130, "title": "Array Field Indexing", "text": "const ms = new MiniSearch({\n  fields: ['title', 'tags'],\n  extractField: (doc, field) => {\n    const val = doc[field];\n    return Array.isArray(val) ? val.join(' ') : val;\n  }\n});\n// Joins array fields into a single string for indexing", "tags": ["array", "extractField", "join"], "category": "examples" },

  { "id": 131, "title": "Electron Desktop Search", "text": "Use MiniSearch in Electron apps for lightning-fast local search of files, notes, or any indexed content. No network dependency means the app works fully offline.", "tags": ["electron", "desktop", "offline"], "category": "use-cases" },
  { "id": 132, "title": "Browser Extension Search", "text": "Build a browser extension with MiniSearch to search through bookmarks, history, or tab titles. The small bundle size keeps the extension lightweight.", "tags": ["extension", "browser", "lightweight"], "category": "use-cases" },
  { "id": 133, "title": "Game Asset Search", "text": "Index game assets (sprites, sounds, 3D models) by name, tags, and description. Developers quickly find the assets they need during game development.", "tags": ["games", "assets", "creative"], "category": "use-cases" },
  { "id": 134, "title": "Scientific Paper Search", "text": "Index paper titles, abstracts, and keywords for quick literature search. Researchers find relevant papers without waiting for slow database queries.", "tags": ["science", "papers", "research"], "category": "use-cases" },
  { "id": 135, "title": "Podcast / Video Search", "text": "Index transcripts or metadata of podcasts and videos. Users search for topics mentioned in episodes without watching/listening to find them.", "tags": ["podcast", "video", "transcripts"], "category": "use-cases" },

  { "id": 136, "title": "Error Handling: Duplicate ID", "text": "MiniSearch throws an error if you try to add() a document with an ID that already exists in the index. Always check with has(id) first, or use replace() for updates.", "tags": ["error", "duplicate", "safety"], "category": "concepts" },
  { "id": 137, "title": "Error Handling: Missing Fields", "text": "If a document is missing a field listed in the constructor's fields array, that field is simply skipped during indexing. No error is thrown—the document is indexed with available fields only.", "tags": ["error", "missing", "graceful"], "category": "concepts" },
  { "id": 138, "title": "Thread Safety", "text": "MiniSearch is not thread-safe. If using it in a web worker, ensure only one thread writes to the index at a time. Multiple read-only searches are safe to run concurrently.", "tags": ["thread", "worker", "concurrency"], "category": "concepts" },
  { "id": 139, "title": "Garbage Collection", "text": "Discarded documents are lazily cleaned up. Call miniSearch.vacuum() periodically if you discard many documents to reclaim memory and maintain search speed.", "tags": ["vacuum", "gc", "memory"], "category": "api" },
  { "id": 140, "title": "miniSearch.vacuum()", "text": "Cleans up the index by removing references to discarded documents. Call this after many discard() operations to optimize memory usage and search performance.", "tags": ["vacuum", "cleanup", "optimize"], "category": "api" },

  { "id": 141, "title": "Async Indexing Pattern", "text": "// Index in batches to avoid blocking the main thread\nasync function indexInBatches(ms, docs, batchSize = 100) {\n  for (let i = 0; i < docs.length; i += batchSize) {\n    ms.addAll(docs.slice(i, i + batchSize));\n    await new Promise(r => setTimeout(r, 0));\n  }\n}", "tags": ["async", "batches", "non-blocking"], "category": "examples" },
  { "id": 142, "title": "Search Result Mapping", "text": "// Map results back to full documents\nconst docMap = new Map(docs.map(d => [d.id, d]));\nconst results = ms.search(query).map(r => ({\n  ...r,\n  document: docMap.get(r.id)\n}));", "tags": ["mapping", "documents", "lookup"], "category": "examples" },
  { "id": 143, "title": "Locale-aware Tokenizer", "text": "const ms = new MiniSearch({\n  fields: ['text'],\n  tokenize: (text) => {\n    const segmenter = new Intl.Segmenter('ja', { granularity: 'word' });\n    return [...segmenter.segment(text)].filter(s => s.isWordLike).map(s => s.segment);\n  }\n});\n// Japanese word segmentation", "tags": ["locale", "intl", "japanese"], "category": "examples" },

  { "id": 144, "title": "Project Governance", "text": "MiniSearch is maintained by Luca Ongaro. It is released under the MIT license. The project has thousands of GitHub stars and is actively maintained with regular releases.", "tags": ["license", "mit", "governance"], "category": "concepts" },
  { "id": 145, "title": "npm Installation", "text": "Install MiniSearch with npm:\n\nnpm install minisearch\n\nOr with yarn:\n\nyarn add minisearch\n\nThe package includes TypeScript declarations.", "tags": ["install", "npm", "yarn"], "category": "api" },
  { "id": 146, "title": "CDN Usage", "text": "Use MiniSearch from a CDN without npm:\n\n<script src=\"https://cdn.jsdelivr.net/npm/minisearch/dist/umd/index.min.js\"></script>\n<script>const ms = new MiniSearch({ fields: ['title'] });</script>", "tags": ["cdn", "script", "no-npm"], "category": "api" },
  { "id": 147, "title": "ES Module Import", "text": "import MiniSearch from 'minisearch';\n\n// Named import for types\nimport MiniSearch, { SearchResult, Suggestion } from 'minisearch';", "tags": ["esm", "import", "types"], "category": "api" },

  { "id": 148, "title": "Tagging Strategy", "text": "Design your tag system to support both broad (category-level) and narrow (specific topic) tags. MiniSearch can search across tags as a field, enabling powerful filtering combinations.", "tags": ["strategy", "tags", "design"], "category": "concepts" },
  { "id": 149, "title": "Field Design Best Practices", "text": "Keep indexed fields focused. A short 'title' field with high boost and a longer 'text' field with normal weight gives the best relevance ranking. Avoid indexing very long fields unless necessary.", "tags": ["best-practices", "fields", "design"], "category": "concepts" },
  { "id": 150, "title": "Testing Search Quality", "text": "Write test cases for expected search behavior: given query X, result Y should appear in the top 3. Automated relevance tests catch regressions when you change tokenization or boosting.", "tags": ["testing", "quality", "regression"], "category": "concepts" },

  { "id": 151, "title": "Debounce Best Practices", "text": "Use 150-300 ms debounce for search input. Too short (50 ms) wastes CPU on intermediate results. Too long (500+ ms) feels sluggish. 200 ms is a good default.", "tags": ["debounce", "ux", "performance"], "category": "concepts" },
  { "id": 152, "title": "Accessibility in Search UI", "text": "Ensure search inputs have proper aria-label or aria-labelledby. Use role='search' on the form. Announce result counts with aria-live='polite'. Support keyboard navigation in result lists.", "tags": ["a11y", "aria", "keyboard"], "category": "concepts" },
  { "id": 153, "title": "Loading State Pattern", "text": "Show a loading indicator while the index is being built (especially for larger datasets). Use Angular signals or observables to track indexing state and update the UI accordingly.", "tags": ["loading", "state", "ux"], "category": "concepts" },
  { "id": 154, "title": "Empty State Pattern", "text": "When no results match, show a helpful empty state: suggest checking spelling, trying broader terms, or disabling strict AND mode. Never show a blank screen.", "tags": ["empty", "no-results", "ux"], "category": "concepts" },
  { "id": 155, "title": "Error State Pattern", "text": "Handle index creation errors gracefully. If the dataset fails to load (network error, malformed JSON), show a clear error message with a retry button.", "tags": ["error", "retry", "ux"], "category": "concepts" },

  { "id": 156, "title": "Comparison: MiniSearch vs Algolia", "text": "Algolia is a hosted search-as-a-service with advanced features (AI, analytics, A/B testing). MiniSearch is self-contained and free, ideal when you do not need server infrastructure or usage-based pricing.", "tags": ["comparison", "algolia", "hosted"], "category": "use-cases" },
  { "id": 157, "title": "Comparison: MiniSearch vs Typesense", "text": "Typesense is a fast open-source search server. Choose Typesense for large datasets with server infrastructure; choose MiniSearch for client-only search without backend dependencies.", "tags": ["comparison", "typesense", "server"], "category": "use-cases" },
  { "id": 158, "title": "Comparison: MiniSearch vs Meilisearch", "text": "Meilisearch is a Rust-based search engine with a REST API. It excels at large datasets and multi-tenant scenarios. MiniSearch is simpler, lighter, and runs entirely in the browser.", "tags": ["comparison", "meilisearch", "rust"], "category": "use-cases" },
  { "id": 159, "title": "Migration from Lunr.js", "text": "Migrating from Lunr.js? Key differences: MiniSearch supports incremental indexing (no rebuild), has built-in autoSuggest, and allows runtime add/remove of documents.", "tags": ["migration", "lunr", "upgrade"], "category": "use-cases" },
  { "id": 160, "title": "Migration from Fuse.js", "text": "Migrating from Fuse.js? MiniSearch adds TF-IDF ranking, prefix search, and auto-suggest. Replace Fuse's threshold option with MiniSearch's fuzzy parameter for typo tolerance.", "tags": ["migration", "fuse", "upgrade"], "category": "use-cases" },

  { "id": 161, "title": "Search Analytics Pattern", "text": "Track search queries and result counts to understand what users look for. Log: query text, number of results, and whether the user clicked a result. Use this data to improve content and relevance.", "tags": ["analytics", "tracking", "improvement"], "category": "concepts" },
  { "id": 162, "title": "Relevance Tuning", "text": "Improve search relevance by: adjusting field boosts, adding synonyms via processTerm, tuning fuzzy thresholds, and testing with real user queries. Iterate based on search analytics.", "tags": ["relevance", "tuning", "optimization"], "category": "concepts" },
  { "id": 163, "title": "Synonyms via processTerm", "text": "Implement synonyms by mapping terms in processTerm:\n\nconst synonyms = { js: 'javascript', ts: 'typescript' };\nprocessTerm: (term) => synonyms[term] || term", "tags": ["synonyms", "processTerm", "mapping"], "category": "examples" },
  { "id": 164, "title": "Accent Folding", "text": "Remove diacritical marks for accent-insensitive search:\n\nprocessTerm: (term) => term.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase()", "tags": ["accents", "diacritics", "normalization"], "category": "examples" },
  { "id": 165, "title": "CamelCase Splitting", "text": "Split camelCase identifiers for searchability:\n\ntokenize: (text) => text.split(/(?=[A-Z])|[\\s_-]+/).map(t => t.toLowerCase()).filter(Boolean)", "tags": ["camelCase", "splitting", "identifiers"], "category": "examples" },

  { "id": 166, "title": "Keyboard Navigation in Results", "text": "Implement arrow-key navigation through search results. Track the active index, use ArrowDown/ArrowUp to change it, and Enter to select. Add aria-activedescendant for screen readers.", "tags": ["keyboard", "navigation", "a11y"], "category": "concepts" },
  { "id": 167, "title": "Search Shortcut (Ctrl+K / Cmd+K)", "text": "Add a global keyboard shortcut to focus the search input. Ctrl+K (Windows/Linux) or Cmd+K (Mac) is the de facto standard in modern web applications.", "tags": ["shortcut", "keyboard", "focus"], "category": "concepts" },
  { "id": 168, "title": "Result Snippet Generation", "text": "Generate context-aware snippets by finding the matched term in the full text and extracting surrounding words. Show 20-30 words around the match with ellipsis.", "tags": ["snippets", "context", "display"], "category": "concepts" },
  { "id": 169, "title": "Virtualized Result List", "text": "For large result sets, use virtual scrolling to render only visible items. Libraries like @angular/cdk virtual scroll integrate well with MiniSearch results.", "tags": ["virtual-scroll", "performance", "cdk"], "category": "concepts" },
  { "id": 170, "title": "Responsive Search Layout", "text": "On mobile, search results should stack vertically with larger touch targets. On desktop, consider a side-panel or modal layout. Use CSS media queries for responsive behavior.", "tags": ["responsive", "mobile", "layout"], "category": "concepts" },

  { "id": 171, "title": "Cursor-based Suggestions UI", "text": "const suggestions = ms.autoSuggest(query, { prefix: true });\n// Render as a dropdown below the input\n// Highlight the matching prefix in each suggestion\n// Navigate with arrow keys, select with Enter", "tags": ["suggestions", "dropdown", "ui"], "category": "examples" },
  { "id": 172, "title": "Search with Date Range", "text": "const results = ms.search(query, {\n  filter: (r) => {\n    const d = new Date(r.date);\n    return d >= startDate && d <= endDate;\n  }\n});\n// Combine text search with date filtering", "tags": ["date", "range", "filter"], "category": "examples" },
  { "id": 173, "title": "Multi-index Search", "text": "// Search across multiple indices and merge results\nconst r1 = index1.search(query);\nconst r2 = index2.search(query);\nconst merged = [...r1, ...r2].sort((a, b) => b.score - a.score);", "tags": ["multi-index", "merge", "advanced"], "category": "examples" },
  { "id": 174, "title": "Search Result Caching", "text": "const cache = new Map();\nfunction cachedSearch(query) {\n  if (!cache.has(query)) {\n    cache.set(query, ms.search(query));\n  }\n  return cache.get(query);\n}\n// Clear cache when index changes", "tags": ["caching", "performance", "map"], "category": "examples" },
  { "id": 175, "title": "Progressive Search Enhancement", "text": "Start with basic string matching, then progressively enable: prefix search → fuzzy search → field boosting → filtering. Each level adds complexity but improves the search experience.", "tags": ["progressive", "enhancement", "strategy"], "category": "concepts" },

  { "id": 176, "title": "Task Runner Search", "text": "Index npm scripts, Makefile targets, or CI pipeline steps. Developers quickly find the command they need without remembering exact names or reading documentation.", "tags": ["tasks", "scripts", "devops"], "category": "use-cases" },
  { "id": 177, "title": "Configuration Finder", "text": "Index configuration keys across .env files, YAML configs, and JSON settings. Teams find where a specific setting is defined without grepping through dozens of files.", "tags": ["config", "settings", "search"], "category": "use-cases" },
  { "id": 178, "title": "Component Library Search", "text": "Build a searchable component library/storybook. Index component names, descriptions, props, and usage examples. Designers and developers find components instantly.", "tags": ["components", "storybook", "design-system"], "category": "use-cases" },
  { "id": 179, "title": "Meeting Notes Search", "text": "Index meeting notes, action items, and decisions. Team members search for past discussions and decisions without scrolling through weeks of notes.", "tags": ["meetings", "notes", "team"], "category": "use-cases" },
  { "id": 180, "title": "Changelog Search", "text": "Index changelog entries by version, date, and description. Users and developers find when a specific feature was added or a bug was fixed.", "tags": ["changelog", "versions", "history"], "category": "use-cases" },

  { "id": 181, "title": "Field-specific Fuzzy Example", "text": "// Apply fuzzy only to the title field\nconst results = ms.search('anglar', {\n  fuzzy: (term, i, terms) => term.length > 3 ? 0.2 : false\n});\n// Short terms use exact match, long terms allow typos", "tags": ["fuzzy", "conditional", "advanced"], "category": "examples" },
  { "id": 182, "title": "Boost by Recency", "text": "// Boost newer documents by combining score with date\nconst results = ms.search(query).map(r => ({\n  ...r,\n  adjustedScore: r.score * (1 + 1 / (Date.now() - new Date(r.date).getTime()))\n})).sort((a, b) => b.adjustedScore - a.adjustedScore);", "tags": ["boost", "recency", "date"], "category": "examples" },
  { "id": 183, "title": "Negative Filter Example", "text": "// Exclude specific categories\nconst results = ms.search(query, {\n  filter: (r) => r.category !== 'archived'\n});\n// Everything except 'archived' category", "tags": ["filter", "exclude", "negative"], "category": "examples" },
  { "id": 184, "title": "Search with Fallback", "text": "// Try strict AND first, fall back to OR if no results\nlet results = ms.search(query, { combineWith: 'AND' });\nif (results.length === 0) {\n  results = ms.search(query, { combineWith: 'OR' });\n}", "tags": ["fallback", "AND", "OR"], "category": "examples" },
  { "id": 185, "title": "Top-N Results Pattern", "text": "// Get only top 5 results\nconst top5 = ms.search(query).slice(0, 5);\n// Useful for suggestion dropdowns or preview panels", "tags": ["top-n", "limit", "slice"], "category": "examples" },

  { "id": 186, "title": "Index Warm-up Strategy", "text": "For optimal UX, build the search index as soon as the dataset is available (e.g. on app init or route resolve). This way the index is ready before the user starts typing.", "tags": ["warm-up", "preload", "strategy"], "category": "concepts" },
  { "id": 187, "title": "Partial Index Updates", "text": "When only a few documents change, use replace() instead of rebuilding the entire index. This is much faster and avoids a visible delay in the UI.", "tags": ["partial", "update", "efficiency"], "category": "concepts" },
  { "id": 188, "title": "Search UX Anti-patterns", "text": "Avoid: auto-searching on every keystroke without debounce, showing raw scores to users, requiring exact queries, hiding the search input, or not handling the empty state.", "tags": ["anti-patterns", "ux", "avoid"], "category": "concepts" },
  { "id": 189, "title": "Index Size Estimation", "text": "Rule of thumb: the in-memory index is roughly 2-5x the size of the source text data. For 1 MB of text, expect 2-5 MB of memory usage. Strings are the main cost.", "tags": ["memory", "estimation", "planning"], "category": "concepts" },
  { "id": 190, "title": "Choosing Between fuzzy and prefix", "text": "Use prefix for autocomplete (user is still typing). Use fuzzy for completed queries with possible typos. Combine both for maximum flexibility, but be aware of slightly larger result sets.", "tags": ["fuzzy", "prefix", "decision"], "category": "concepts" },

  { "id": 191, "title": "Conditional Prefix Example", "text": "// Enable prefix only for the last term (typeahead)\nconst results = ms.search(query, {\n  prefix: (term, i, terms) => i === terms.length - 1\n});\n// Earlier terms must match exactly", "tags": ["prefix", "conditional", "typeahead"], "category": "examples" },
  { "id": 192, "title": "Search Input with Clear Button", "text": "// Angular template snippet\n// <input [(ngModel)]='query' />\n// <button *ngIf='query' (click)='query = \"\"'>Clear</button>\n// Always provide a way to clear the search input", "tags": ["clear", "input", "ux"], "category": "examples" },
  { "id": 193, "title": "Result Count Display", "text": "// Show total results and search time\nconst start = performance.now();\nconst results = ms.search(query);\nconst time = (performance.now() - start).toFixed(1);\nconsole.log(`${results.length} results in ${time}ms`);", "tags": ["count", "timing", "display"], "category": "examples" },
  { "id": 194, "title": "Lazy Loading Dataset", "text": "// Load the dataset only when the search page is accessed\nasync function loadAndIndex() {\n  const res = await fetch('/minisearch-docs.json');\n  const docs = await res.json();\n  ms.addAll(docs);\n}", "tags": ["lazy", "fetch", "load"], "category": "examples" },
  { "id": 195, "title": "Index Rebuild on Data Change", "text": "// When the source data changes, rebuild the index\nfunction rebuildIndex(docs) {\n  const ms = new MiniSearch({ fields: ['title', 'text'] });\n  ms.addAll(docs);\n  return ms;\n}\n// Replace the old instance with the new one", "tags": ["rebuild", "data-change", "fresh"], "category": "examples" },

  { "id": 196, "title": "SSR Considerations", "text": "MiniSearch runs in any JS environment, including server-side rendering. You can build the index server-side and transfer it to the client via loadJSON() for instant availability.", "tags": ["ssr", "server-rendering", "transfer"], "category": "concepts" },
  { "id": 197, "title": "Testing with Vitest", "text": "import { describe, it, expect } from 'vitest';\nimport MiniSearch from 'minisearch';\n\ndescribe('Search', () => {\n  it('finds documents by title', () => {\n    const ms = new MiniSearch({ fields: ['title'] });\n    ms.addAll([{ id: 1, title: 'Angular' }]);\n    expect(ms.search('angular')).toHaveLength(1);\n  });\n});", "tags": ["vitest", "testing", "unit"], "category": "examples" },
  { "id": 198, "title": "Performance Measurement", "text": "function measureSearch(ms, query, runs = 20) {\n  const times = [];\n  for (let i = 0; i < runs; i++) {\n    const start = performance.now();\n    ms.search(query);\n    times.push(performance.now() - start);\n  }\n  times.sort((a, b) => a - b);\n  return { median: times[Math.floor(runs/2)], p95: times[Math.floor(runs*0.95)] };\n}", "tags": ["performance", "benchmark", "measurement"], "category": "examples" },
  { "id": 199, "title": "Versioning Strategy", "text": "MiniSearch follows semantic versioning. Major versions may include breaking API changes. Check the changelog before upgrading. Minor versions add features, patch versions fix bugs.", "tags": ["versioning", "semver", "changelog"], "category": "concepts" },
  { "id": 200, "title": "Community and Support", "text": "MiniSearch has an active GitHub repository with issues, discussions, and pull requests. The documentation covers all API methods with examples. Stack Overflow also has answers for common questions.", "tags": ["community", "support", "github"], "category": "concepts" }
]
