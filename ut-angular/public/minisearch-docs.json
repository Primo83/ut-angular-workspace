[
  { "id": 1, "title": "Czym jest MiniSearch?", "text": "MiniSearch to lekka biblioteka JavaScript do wyszukiwania pełnotekstowego, bez zależności. Działa w całości po stronie klienta, w pamięci, bez potrzeby serwera ani zewnętrznej usługi. Spakowana (gzip) waży tylko ok. 7 kB.", "tags": ["overview", "introduction", "client-side"], "category": "concepts" },
  { "id": 2, "title": "Ranking TF-IDF", "text": "MiniSearch używa TF-IDF (Term Frequency–Inverse Document Frequency), aby oceniać trafność i sortować wyniki. Terminy, które często pojawiają się w danym dokumencie, ale rzadko w całym zbiorze, dostają wyższy wynik.", "tags": ["ranking", "relevance", "scoring"], "category": "concepts" },
  { "id": 3, "title": "Indeks odwrócony", "text": "W środku MiniSearch buduje indeks odwrócony, mapując każdy termin na dokumenty, które go zawierają. Taka struktura danych pozwala na wyszukiwanie poniżej 1 ms nawet dla dużych zestawów dokumentów.", "tags": ["internals", "index", "performance"], "category": "concepts" },
  { "id": 4, "title": "Tokenizacja", "text": "Tokenizacja dzieli tekst na pojedyncze terminy. MiniSearch używa domyślnego tokenizera, który rozdziela po znakach innych niż litery i cyfry, ale możesz podać własną funkcję tokenizującą dla specyficznych języków lub formatów.", "tags": ["tokenizer", "text-processing", "customization"], "category": "concepts" },
  { "id": 5, "title": "Pipeline przetwarzania terminów", "text": "Po tokenizacji terminy przechodzą przez pipeline przetwarzania: zamianę na małe litery, opcjonalny stemming i usuwanie stop words. Każdy krok może być dostosowany albo zastąpiony.", "tags": ["stemming", "lowercase", "stop-words"], "category": "concepts" },
  { "id": 6, "title": "Wyszukiwanie prefiksowe", "text": "Wyszukiwanie prefiksowe dopasowuje dokumenty zawierające terminy zaczynające się od zapytania. Jest idealne do autouzupełniania (typeahead). Włączysz je przez `{ prefix: true }`.", "tags": ["prefix", "autocomplete", "typeahead"], "category": "concepts" },
  { "id": 7, "title": "Wyszukiwanie rozmyte (fuzzy)", "text": "Wyszukiwanie rozmyte (fuzzy) toleruje literówki dzięki konfigurowalnej odległości edycyjnej (Levenshtein). Ustaw `{ fuzzy: 0.2 }`, aby dopuścić do 20% zmian względem długości terminu.", "tags": ["fuzzy", "typo-tolerance", "levenshtein"], "category": "concepts" },
  { "id": 8, "title": "Ważenie pól (boost)", "text": "Boosting przypisuje różne wagi polom indeksu. Na przykład `boost: { title: 2 }` sprawia, że dopasowania w tytule liczą się dwa razy bardziej niż w innych polach.", "tags": ["boosting", "weights", "relevance"], "category": "concepts" },
  { "id": 9, "title": "Filtrowanie wyników", "text": "Możesz filtrować wyniki wyszukiwania callbackiem. `filter` dostaje każdy obiekt wyniku i zwraca `true`, aby go zostawić. To przydatne przy fasetach lub filtrowaniu po kategoriach.", "tags": ["filter", "facets", "callback"], "category": "concepts" },
  { "id": 10, "title": "Podpowiedzi (autoSuggest)", "text": "Metoda `autoSuggest` zwraca podpowiedzi (z wagą) na podstawie częściowego wpisu. Łączy dopasowanie prefiksowe z rankingiem, żeby wybrać najbardziej prawdopodobne dokończenia.", "tags": ["autosuggest", "suggestions", "completions"], "category": "concepts" },
  { "id": 11, "title": "Strategie łączenia (AND / OR)", "text": "Domyślnie MiniSearch łączy wiele terminów zapytania operatorem OR. Ustaw `{ combineWith: 'AND' }`, aby wymagać obecności wszystkich terminów w dokumencie.", "tags": ["combine", "boolean", "AND", "OR"], "category": "concepts" },
  { "id": 12, "title": "Indeksowanie przyrostowe", "text": "W odróżnieniu od bibliotek wymagających pełnej przebudowy, MiniSearch wspiera dodawanie i usuwanie dokumentów w trakcie działania przez `add()`, `remove()`, `discard()` i `replace()`.", "tags": ["incremental", "runtime", "dynamic"], "category": "concepts" },
  { "id": 13, "title": "Serializacja indeksu", "text": "Możesz zserializować cały indeks przez `JSON.stringify(miniSearch)` i odtworzyć go przez `MiniSearch.loadJSON()`. To umożliwia indeksowanie w buildzie i natychmiastowe wyszukiwanie po załadowaniu strony.", "tags": ["serialization", "json", "build-time"], "category": "concepts" },
  { "id": 14, "title": "Zero zależności", "text": "MiniSearch nie ma zależności uruchomieniowych. Cała biblioteka jest samowystarczalna, dzięki czemu bundle jest mały i mniej narażony na ryzyka z zależności pośrednich.", "tags": ["dependencies", "bundle-size", "lightweight"], "category": "concepts" },
  { "id": 15, "title": "Wsparcie TypeScript", "text": "MiniSearch zawiera natywne deklaracje typów TypeScript. Dostajesz IntelliSense, sprawdzanie typów opcji i wyników oraz generyczne typy dokumentów.", "tags": ["typescript", "types", "intellisense"], "category": "concepts" },
  { "id": 16, "title": "Przeglądarka i Node.js", "text": "MiniSearch działa w każdym środowisku JavaScript: nowoczesne przeglądarki, Node.js, Deno i web workery. Nie ma zależności od DOM ani platformy.", "tags": ["browser", "node", "universal"], "category": "concepts" },
  { "id": 17, "title": "Wyjaśnienie wyniku (score)", "text": "Każdy wynik ma właściwość `score` (liczba zmiennoprzecinkowa) oraz obiekt `match`, który pokazuje, które pola i terminy się dopasowały. Używaj tego do debugowania trafności.", "tags": ["score", "match", "debugging"], "category": "concepts" },
  { "id": 18, "title": "Indeksowanie wielu pól", "text": "Indeksuj jednocześnie wiele pól (np. title, text, tags). Każde pole może mieć własną wagę w rankingu i może być osobno wskazane w zapytaniu.", "tags": ["multi-field", "fields", "indexing"], "category": "concepts" },
  { "id": 19, "title": "Przechowywane pola (storeFields)", "text": "Opcja `storeFields` określa, które pola mają być dołączone do wyników wyszukiwania. Tylko przechowywane pola pojawiają się w obiektach wyniku, co pomaga oszczędzać pamięć.", "tags": ["storeFields", "memory", "results"], "category": "concepts" },
  { "id": 20, "title": "Własny tokenizer (tokenize)", "text": "Zastąp domyślny tokenizer, przekazując funkcję `tokenize` w opcjach. Przydatne dla języków CJK, rozbijania camelCase albo tokenizacji domenowej.", "tags": ["tokenizer", "custom", "CJK"], "category": "concepts" },
  { "id": 21, "title": "Słowa pomijalne (stop words)", "text": "Stop words to bardzo częste słowa (np. 'the', 'is', 'at'), które dodają szum do wyników. MiniSearch nie usuwa ich domyślnie, ale możesz dodać własne `processTerm`, aby je odfiltrować.", "tags": ["stop-words", "noise", "processTerm"], "category": "concepts" },
  { "id": 22, "title": "Stemming (sprowadzanie do rdzenia)", "text": "Stemming sprowadza słowa do rdzenia (np. 'running' → 'run'). MiniSearch nie ma wbudowanego stemmera, ale możesz go podpiąć przez opcję `processTerm`.", "tags": ["stemming", "root-form", "processTerm"], "category": "concepts" },
  { "id": 23, "title": "Zużycie pamięci", "text": "Indeks odwrócony jest kompaktowy. Dla typowych datasetów (setki do kilku tysięcy dokumentów) zużycie pamięci zwykle pozostaje znacznie poniżej 10 MB, więc działa też dobrze na mobile.", "tags": ["memory", "footprint", "mobile"], "category": "concepts" },
  { "id": 24, "title": "Wydajność wyszukiwania", "text": "Zapytania zwykle kończą się w czasie poniżej 1 ms dla datasetów do kilku tysięcy dokumentów. Wydajność skaluje się w przybliżeniu liniowo wraz z rozmiarem zbioru.", "tags": ["performance", "speed", "latency"], "category": "concepts" },
  { "id": 25, "title": "Wydajność indeksowania", "text": "Zindeksowanie 1 000 dokumentów zwykle zajmuje mniej niż 100 ms. Dla bardzo dużych datasetów rozważ indeksowanie w web workerze albo na etapie builda.", "tags": ["indexing", "build-time", "web-worker"], "category": "concepts" },

  { "id": 26, "title": "new MiniSearch(options)", "text": "Tworzy nową instancję MiniSearch. Wymagana opcja: `fields` (tablica nazw pól do indeksowania). Opcjonalnie: `storeFields`, `idField`, `tokenize`, `processTerm`, `searchOptions`.", "tags": ["constructor", "options", "initialization"], "category": "api" },
  { "id": 27, "title": "miniSearch.add(document)", "text": "Dodaje pojedynczy dokument do indeksu. Dokument musi mieć unikalne pole ID (domyślnie: 'id') oraz pola wskazane w konstruktorze.", "tags": ["add", "document", "index"], "category": "api" },
  { "id": 28, "title": "miniSearch.addAll(documents)", "text": "Dodaje tablicę dokumentów hurtowo do indeksu. Jest wydajniejsze niż wywoływanie add() w pętli, bo grupuje aktualizacje wewnętrzne.", "tags": ["addAll", "bulk", "batch"], "category": "api" },
  { "id": 29, "title": "miniSearch.search(query, options?)", "text": "Wykonuje wyszukiwanie pełnotekstowe i zwraca tablicę wyników posortowanych wg trafności (score). Opcje: prefix, fuzzy, boost, filter, combineWith, fields.", "tags": ["search", "query", "results"], "category": "api" },
  { "id": 30, "title": "miniSearch.autoSuggest(query, options?)", "text": "Zwraca tablicę obiektów { suggestion, score } na podstawie częściowego wpisu. Przydatne do budowy dropdownu autouzupełniania. Przyjmuje te same opcje co search().", "tags": ["autoSuggest", "autocomplete", "dropdown"], "category": "api" },
  { "id": 31, "title": "miniSearch.remove(document)", "text": "Usuwa wcześniej zindeksowany dokument z indeksu. Dokument musi odpowiadać oryginałowi (to samo ID i pola).", "tags": ["remove", "delete", "document"], "category": "api" },
  { "id": 32, "title": "miniSearch.discard(id)", "text": "Miękko usuwa dokument po jego ID bez potrzeby przekazywania oryginalnego obiektu dokumentu. Jest trochę mniej wydajne niż remove(), ale wygodniejsze.", "tags": ["discard", "soft-delete", "id"], "category": "api" },
  { "id": 33, "title": "miniSearch.replace(document)", "text": "Zastępuje dokument w indeksie. To odpowiednik remove() + add(), ale wykonany atomowo. Nowy dokument musi mieć to samo ID.", "tags": ["replace", "update", "atomic"], "category": "api" },
  { "id": 34, "title": "MiniSearch.loadJSON(json, options)", "text": "Metoda statyczna, która odtwarza instancję MiniSearch z JSON-a. Opcje muszą pasować do tych z konstruktora (fields, storeFields itd.).", "tags": ["loadJSON", "deserialize", "static"], "category": "api" },
  { "id": 35, "title": "JSON.stringify(miniSearch)", "text": "Serializuje cały indeks do JSON-a. Wynik można zapisać do pliku albo wysłać do klienta, żeby natychmiast odtworzyć go przez loadJSON().", "tags": ["stringify", "serialize", "export"], "category": "api" },
  { "id": 36, "title": "Opcja wyszukiwania: prefix", "text": "Gdy prefix jest true, każdy termin zapytania jest traktowany jak prefiks. 'ang' dopasuje 'angular', 'angularjs' itd. Może to być boolean albo funkcja (term, i, terms) => boolean.", "tags": ["prefix", "option", "boolean"], "category": "api" },
  { "id": 37, "title": "Opcja wyszukiwania: fuzzy", "text": "Steruje tolerancją literówek. Liczba 0–1 ustawia maksymalną odległość edycji jako ułamek długości terminu. 0.2 oznacza, że do 20% znaków może się różnić.", "tags": ["fuzzy", "option", "edit-distance"], "category": "api" },
  { "id": 38, "title": "Opcja wyszukiwania: boost", "text": "Obiekt mapujący nazwy pól na współczynniki wagi. { title: 2, tags: 1.5 } sprawia, że dopasowania w tytule są 2x ważniejsze, a w tagach 1.5x.", "tags": ["boost", "option", "weight"], "category": "api" },
  { "id": 39, "title": "Opcja wyszukiwania: filter", "text": "Callback (result) => boolean, który filtruje wyniki po policzeniu punktacji. Przydatne do faset kategorii, zakresów dat lub dowolnej logiki filtrowania po stronie klienta.", "tags": ["filter", "option", "callback"], "category": "api" },
  { "id": 40, "title": "Opcja wyszukiwania: combineWith", "text": "Ustaw na 'AND', aby wymagać wszystkich terminów w dokumencie. Domyślnie jest 'OR'. Możesz też użyć 'AND_NOT' dla zapytań wykluczających.", "tags": ["combineWith", "AND", "OR"], "category": "api" },
  { "id": 41, "title": "Opcja wyszukiwania: fields", "text": "Tablica nazw pól, w których ma być wykonane wyszukiwanie. Domyślnie przeszukiwane są wszystkie zindeksowane pola. Użyj tego, aby ograniczyć wyszukiwanie do konkretnych pól.", "tags": ["fields", "option", "restrict"], "category": "api" },
  { "id": 42, "title": "Opcja konstruktora: idField", "text": "Nazwa pola będącego unikalnym identyfikatorem. Domyślnie: 'id'. Ustaw, jeśli Twoje dokumenty używają innego klucza, np. _id albo uuid.", "tags": ["idField", "constructor", "identifier"], "category": "api" },
  { "id": 43, "title": "Opcja konstruktora: tokenize", "text": "Własna funkcja tokenizująca (text, fieldName) => string[]. Wywoływana zarówno przy indeksowaniu, jak i wyszukiwaniu. Zastępuje domyślny tokenizer dzielący po białych znakach/interpunkcji.", "tags": ["tokenize", "constructor", "custom"], "category": "api" },
  { "id": 44, "title": "Opcja konstruktora: processTerm", "text": "Funkcja (term, fieldName) => string | null. Stosowana po tokenizacji do każdego terminu. Zwróć null, aby pominąć termin (przydatne do stop words).", "tags": ["processTerm", "constructor", "pipeline"], "category": "api" },
  { "id": 45, "title": "Opcja konstruktora: storeFields", "text": "Tablica nazw pól, które mają trafić do wyników wyszukiwania. Pola te są przechowywane obok indeksu i zwracane w każdym obiekcie wyniku.", "tags": ["storeFields", "constructor", "results"], "category": "api" },
  { "id": 46, "title": "Opcja konstruktora: fields", "text": "Wymagane. Tablica nazw pól do indeksowania. Pola są tokenizowane i dodawane do indeksu odwróconego.", "tags": ["fields", "constructor", "required"], "category": "api" },
  { "id": 47, "title": "Właściwości obiektu wyniku", "text": "Każdy wynik ma: id (ID dokumentu), score (trafność), match (obiekt dopasowanych terminów/pól) oraz pola wymienione w storeFields.", "tags": ["result", "score", "match"], "category": "api" },
  { "id": 48, "title": "miniSearch.documentCount", "text": "Właściwość tylko do odczytu, która zwraca liczbę dokumentów aktualnie w indeksie. Przydatne do wyświetlenia w UI lub szybkich health-checków.", "tags": ["documentCount", "property", "count"], "category": "api" },
  { "id": 49, "title": "miniSearch.termCount", "text": "Zwraca liczbę unikalnych terminów w indeksie. Pomaga zrozumieć rozmiar słownika i złożoność indeksu.", "tags": ["termCount", "property", "vocabulary"], "category": "api" },
  { "id": 50, "title": "Opcja wyszukiwania: maxFuzzy", "text": "Ogranicza maksymalną bezwzględną odległość edycji dla fuzzy. Domyślnie nie ma twardego limitu poza ułamkowym ustawieniem fuzzy. Ustaw maxFuzzy: 3, aby ograniczyć liczbę zmian.", "tags": ["maxFuzzy", "option", "limit"], "category": "api" },

  { "id": 51, "title": "Przykład: podstawowe wyszukiwanie", "text": "const ms = new MiniSearch({ fields: ['title', 'text'] });\nms.addAll(documents);\nconst results = ms.search('angular');\nconsole.log(results);", "tags": ["basic", "search", "quickstart"], "category": "examples" },
  { "id": 52, "title": "Przykład: wyszukiwanie rozmyte (fuzzy)", "text": "// Toleruj literówki do 20% długości terminu\nconst results = ms.search('anglar', { fuzzy: 0.2 });\n// Nadal znajduje dokumenty z 'angular'", "tags": ["fuzzy", "typo", "example"], "category": "examples" },
  { "id": 53, "title": "Przykład: wyszukiwanie prefiksowe", "text": "// Autouzupełnianie: znajdź terminy zaczynające się od 'ang'\nconst results = ms.search('ang', { prefix: true });\n// Dopasuje: angular, angularjs, angle itd.", "tags": ["prefix", "autocomplete", "example"], "category": "examples" },
  { "id": 54, "title": "Przykład: boosting pól", "text": "// Dopasowania w tytule są 2x ważniejsze\nconst results = ms.search('framework', {\n  boost: { title: 2 }\n});\n// Dopasowania w tytule mają wyższy score", "tags": ["boost", "fields", "example"], "category": "examples" },
  { "id": 55, "title": "Przykład: filtr po kategorii", "text": "const results = ms.search('search', {\n  filter: (result) => result.category === 'frontend'\n});\n// Zwraca tylko wyniki z kategorii 'frontend'", "tags": ["filter", "category", "example"], "category": "examples" },
  { "id": 56, "title": "Przykład: autoSuggest", "text": "const suggestions = ms.autoSuggest('rea', { prefix: true });\n// Zwraca: [{ suggestion: 'react', score: 5.2 }, { suggestion: 'read', score: 2.1 }]", "tags": ["autosuggest", "autocomplete", "example"], "category": "examples" },
  { "id": 57, "title": "Przykład: łączenie AND", "text": "// Wymagaj dopasowania WSZYSTKICH terminów\nconst results = ms.search('angular framework', {\n  combineWith: 'AND'\n});\n// Tylko dokumenty zawierające jednocześnie 'angular' i 'framework'", "tags": ["AND", "combine", "example"], "category": "examples" },
  { "id": 58, "title": "Przykład: własny tokenizer", "text": "const ms = new MiniSearch({\n  fields: ['title'],\n  tokenize: (text) => text.split(/[\\s-_]+/)\n});\n// Dzieli po spacjach, myślnikach i podkreśleniach", "tags": ["tokenizer", "custom", "example"], "category": "examples" },
  { "id": 59, "title": "Przykład: stop words", "text": "const stopWords = new Set(['the', 'is', 'at', 'of', 'a']);\nconst ms = new MiniSearch({\n  fields: ['text'],\n  processTerm: (term) => stopWords.has(term) ? null : term\n});", "tags": ["stop-words", "processTerm", "example"], "category": "examples" },
  { "id": 60, "title": "Przykład: stemming", "text": "import { stem } from 'some-stemmer';\nconst ms = new MiniSearch({\n  fields: ['text'],\n  processTerm: (term) => stem(term.toLowerCase())\n});\n// 'running' i 'run' będą teraz dopasowywane", "tags": ["stemming", "processTerm", "example"], "category": "examples" },
  { "id": 61, "title": "Przykład: podświetlanie dopasowań", "text": "const results = ms.search('angular');\nresults.forEach(r => {\n  Object.entries(r.match).forEach(([term, fields]) => {\n    console.log(`Termin '${term}' dopasował się w polach: ${fields}`);\n  });\n});", "tags": ["highlight", "match", "example"], "category": "examples" },
  { "id": 62, "title": "Przykład: serializacja indeksu", "text": "// Zapisz indeks do JSON\nconst json = JSON.stringify(ms);\nlocalStorage.setItem('searchIndex', json);\n\n// Odtwórz później\nconst restored = MiniSearch.loadJSON(json, { fields: ['title', 'text'] });", "tags": ["serialize", "loadJSON", "example"], "category": "examples" },
  { "id": 63, "title": "Przykład: dynamiczne add/remove", "text": "// Dodaj nowy dokument w trakcie działania\nms.add({ id: 999, title: 'Nowy dokument', text: 'Świeża treść' });\n\n// Usuń go później\nms.remove({ id: 999, title: 'Nowy dokument', text: 'Świeża treść' });", "tags": ["dynamic", "add", "remove"], "category": "examples" },
  { "id": 64, "title": "Przykład: discard po ID", "text": "// Miękkie usunięcie bez oryginalnego obiektu dokumentu\nms.discard(42);\n// Dokument 42 jest wykluczony z kolejnych wyszukiwań", "tags": ["discard", "soft-delete", "example"], "category": "examples" },
  { "id": 65, "title": "Przykład: replace dokumentu", "text": "// Atomowa aktualizacja dokumentu\nms.replace({ id: 1, title: 'Zaktualizowany tytuł', text: 'Zaktualizowana treść' });\n// Stara wersja usunięta, nowa zindeksowana", "tags": ["replace", "update", "example"], "category": "examples" },
  { "id": 66, "title": "Przykład: wyszukiwanie wielopolowe", "text": "const ms = new MiniSearch({\n  fields: ['title', 'text', 'tags'],\n  storeFields: ['title', 'category']\n});\nms.addAll(docs);\nconst results = ms.search('router');", "tags": ["multi-field", "storeFields", "example"], "category": "examples" },
  { "id": 67, "title": "Przykład: wyszukiwanie w wybranych polach", "text": "// Szukaj tylko w polu title\nconst results = ms.search('angular', {\n  fields: ['title']\n});\n// Ignoruje dopasowania w 'text' i 'tags'", "tags": ["fields", "restrict", "example"], "category": "examples" },
  { "id": 68, "title": "Przykład: fuzzy + prefix", "text": "// Włącz fuzzy i prefix dla bardziej wybaczającego wyszukiwania\nconst results = ms.search('ang', {\n  prefix: true,\n  fuzzy: 0.2\n});\n// Dopasuje 'angular' nawet przy literówkach i częściowym wpisie", "tags": ["fuzzy", "prefix", "combined"], "category": "examples" },
  { "id": 69, "title": "Przykład: wagi dla wielu pól", "text": "const results = ms.search('search engine', {\n  boost: { title: 3, tags: 2, text: 1 },\n  combineWith: 'AND'\n});\n// Dopasowania w tytule są 3x ważniejsze", "tags": ["boost", "multi-field", "weighted"], "category": "examples" },
  { "id": 70, "title": "Integracja z serwisem Angular", "text": "import { Injectable, signal } from '@angular/core';\nimport MiniSearch from 'minisearch';\n\n@Injectable({ providedIn: 'root' })\nexport class SearchService {\n  private ms = new MiniSearch({ fields: ['title', 'text'] });\n  results = signal([]);\n  search(query: string) { this.results.set(this.ms.search(query)); }\n}", "tags": ["angular", "service", "integration"], "category": "examples" },
  { "id": 71, "title": "Debounce w polu wyszukiwania", "text": "import { Subject, debounceTime } from 'rxjs';\n\nconst query$ = new Subject<string>();\nquery$.pipe(debounceTime(200)).subscribe(q => {\n  const results = ms.search(q, { prefix: true, fuzzy: 0.2 });\n  console.log(results);\n});", "tags": ["debounce", "rxjs", "input"], "category": "examples" },
  { "id": 72, "title": "Indeksowanie w buildzie", "text": "// build-index.mjs (skrypt Node.js)\nimport MiniSearch from 'minisearch';\nimport { readFileSync, writeFileSync } from 'fs';\n\nconst docs = JSON.parse(readFileSync('docs.json'));\nconst ms = new MiniSearch({ fields: ['title', 'text'] });\nms.addAll(docs);\nwriteFileSync('search-index.json', JSON.stringify(ms));", "tags": ["build-time", "node", "script"], "category": "examples" },
  { "id": 73, "title": "Indeksowanie w Web Workerze", "text": "// worker.ts\nimport MiniSearch from 'minisearch';\nself.onmessage = (e) => {\n  const ms = new MiniSearch({ fields: ['title', 'text'] });\n  ms.addAll(e.data);\n  self.postMessage(JSON.stringify(ms));\n};", "tags": ["web-worker", "offload", "example"], "category": "examples" },
  { "id": 74, "title": "Przykład integracji z React", "text": "import { useState, useMemo } from 'react';\nimport MiniSearch from 'minisearch';\n\nfunction Search({ docs }) {\n  const ms = useMemo(() => {\n    const m = new MiniSearch({ fields: ['title', 'text'] });\n    m.addAll(docs);\n    return m;\n  }, [docs]);\n  const [results, setResults] = useState([]);\n  return <input onChange={e => setResults(ms.search(e.target.value))} />;\n}", "tags": ["react", "integration", "hooks"], "category": "examples" },
  { "id": 75, "title": "Przykład integracji z Vue", "text": "import MiniSearch from 'minisearch';\nimport { ref, computed } from 'vue';\n\nconst query = ref('');\nconst ms = new MiniSearch({ fields: ['title', 'text'] });\nms.addAll(docs);\nconst results = computed(() =>\n  query.value ? ms.search(query.value) : []\n);", "tags": ["vue", "integration", "reactive"], "category": "examples" },

  { "id": 76, "title": "Wyszukiwanie w dokumentacji", "text": "MiniSearch napędza wyszukiwanie w narzędziach dokumentacyjnych takich jak VitePress i Docusaurus. Indeksuje dokumenty w buildzie, serializuje indeks i ładuje go natychmiast po starcie strony, dzięki czemu wyszukiwanie może działać offline.", "tags": ["docs", "vitepress", "docusaurus"], "category": "use-cases" },
  { "id": 77, "title": "Autouzupełnianie w formularzach", "text": "Użyj MiniSearch do natychmiastowych podpowiedzi, gdy użytkownik pisze w polach formularza. Prefix search połączony z autoSuggest daje responsywne autouzupełnianie bez wywołań do serwera.", "tags": ["autocomplete", "forms", "typeahead"], "category": "use-cases" },
  { "id": 78, "title": "Filtrowanie tabel po stronie klienta", "text": "Zastąp proste dopasowanie stringów w tabelach danymi z MiniSearch, aby mieć ranking trafności i tolerancję literówek. Użytkownik znajdzie wiersze nawet przy niedokładnym zapytaniu.", "tags": ["table", "filtering", "data-grid"], "category": "use-cases" },
  { "id": 79, "title": "Wyszukiwanie offline / PWA", "text": "Aplikacje PWA i offline-first korzystają z MiniSearch, bo nie potrzebują sieci. Zindeksuj dane raz i wyszukuj lokalnie, nawet bez połączenia.", "tags": ["offline", "pwa", "no-network"], "category": "use-cases" },
  { "id": 80, "title": "Szybkie prototypowanie", "text": "Zamiast stawiać Elasticsearch lub Algolia dla prototypu, wrzuć MiniSearch i od razu masz full-text search. Gdy projekt urośnie, możesz zmigrować do rozwiązania serwerowego.", "tags": ["prototype", "quick-start", "mvp"], "category": "use-cases" },
  { "id": 81, "title": "Wyszukiwanie produktów e-commerce", "text": "Dla małych i średnich katalogów produktów MiniSearch daje szybkie, tolerujące literówki wyszukiwanie z boostingiem pól. Podbijaj nazwy produktów i marki względem opisów, żeby poprawić trafność.", "tags": ["e-commerce", "products", "catalog"], "category": "use-cases" },
  { "id": 82, "title": "Baza wiedzy / FAQ", "text": "Zindeksuj wpisy FAQ i artykuły bazy wiedzy w MiniSearch. Użytkownicy znajdą odpowiedzi nawet z literówkami, dzięki fuzzy matching.", "tags": ["faq", "knowledge-base", "help"], "category": "use-cases" },
  { "id": 83, "title": "Wyszukiwanie w blogu / CMS", "text": "Generatory stron statycznych mogą użyć MiniSearch, aby dodać wyszukiwarkę do bloga lub serwisu z CMS. Indeks budujesz przy deployu i serwujesz jako statyczny plik JSON.", "tags": ["blog", "cms", "static-site"], "category": "use-cases" },
  { "id": 84, "title": "Wyszukiwanie w czacie / wiadomościach", "text": "Zindeksuj wiadomości czatu lub wątki e-maili, żeby mieć szybkie wyszukiwanie lokalne. Indeksowanie przyrostowe sprawia, że nowe wiadomości są wyszukiwalne od razu.", "tags": ["chat", "messages", "incremental"], "category": "use-cases" },
  { "id": 85, "title": "Wyszukiwanie snippetów kodu", "text": "Zbuduj przeszukiwalną bibliotekę snippetów kodu. Indeksuj po języku, opisie i tagach. Fuzzy search pomaga, gdy nie pamiętasz dokładnej nazwy funkcji.", "tags": ["code", "snippets", "developer-tools"], "category": "use-cases" },
  { "id": 86, "title": "Wyszukiwarka przepisów", "text": "Zindeksuj przepisy po nazwie, składnikach i kuchni. Użytkownik szuka 'kurczak makaron' i dostaje trafne przepisy z możliwością filtrowania np. po preferencjach dietetycznych.", "tags": ["recipes", "food", "hobby"], "category": "use-cases" },
  { "id": 87, "title": "Biblioteka muzyki / mediów", "text": "Wyszukuj w bibliotece muzyki po artyście, albumie, tytule utworu i gatunku. Prefix search napędza instant typeahead, gdy użytkownik wpisuje nazwę piosenki.", "tags": ["music", "media", "library"], "category": "use-cases" },
  { "id": 88, "title": "Wyszukiwanie w książce adresowej", "text": "Zindeksuj kontakty po imieniu, e-mailu, telefonie i firmie. Fuzzy search poradzi sobie z literówkami w nazwiskach, a prefix search ułatwia szybkie wyszukiwanie.", "tags": ["contacts", "address-book", "people"], "category": "use-cases" },
  { "id": 89, "title": "Podgląd logów / debugowanie", "text": "Zindeksuj logi aplikacji lub komunikaty błędów, aby szybciej debugować. Boosting pola severity pomaga wypchnąć krytyczne błędy wyżej.", "tags": ["logs", "debugging", "errors"], "category": "use-cases" },
  { "id": 90, "title": "Menedżer zakładek", "text": "Zindeksuj zakładki wraz z tytułami, URL-ami i tagami. MiniSearch pozwala znaleźć zapisane linki natychmiast, nawet po częściowym lub błędnym zapytaniu.", "tags": ["bookmarks", "urls", "organization"], "category": "use-cases" },
  { "id": 91, "title": "Wyniki ankiet / sond", "text": "Zindeksuj odpowiedzi tekstowe z ankiet do analizy jakościowej. Możesz szukać tematów i słów kluczowych w setkach odpowiedzi bez ręcznego czytania.", "tags": ["survey", "responses", "analysis"], "category": "use-cases" },
  { "id": 92, "title": "Glosariusz / słownik", "text": "Zbuduj przeszukiwalny glosariusz lub słownik techniczny. Prefix search obsłuży częściowe terminy, a fuzzy złapie literówki w specjalistycznym słownictwie.", "tags": ["glossary", "dictionary", "terms"], "category": "use-cases" },
  { "id": 93, "title": "Wyszukiwanie w eksploratorze plików", "text": "Zindeksuj nazwy plików i metadane w przeglądarce plików działającej w kliencie. MiniSearch jest wystarczająco szybki, aby przeszukiwać tysiące wpisów w czasie rzeczywistym.", "tags": ["files", "explorer", "metadata"], "category": "use-cases" },
  { "id": 94, "title": "Zarządzanie stanem magazynowym", "text": "Wyszukuj po pozycjach magazynowych po SKU, nazwie, opisie i lokalizacji. Filtruj po magazynie lub kategorii, żeby zawęzić wyniki.", "tags": ["inventory", "warehouse", "sku"], "category": "use-cases" },
  { "id": 95, "title": "Aplikacja quizowa", "text": "Zindeksuj pytania quizowe i materiały do nauki. Uczniowie wyszukują temat i znajdują powiązane pytania, fiszki i notatki.", "tags": ["education", "quiz", "learning"], "category": "use-cases" },
  { "id": 96, "title": "Integracja z VitePress", "text": "VitePress używa MiniSearch jako domyślnego dostawcy wyszukiwania. Indeksuje całą treść markdown w buildzie i daje natychmiastowe wyszukiwanie offline od razu.", "tags": ["vitepress", "vue", "docs"], "category": "use-cases" },
  { "id": 97, "title": "Porównanie: MiniSearch vs Lunr.js", "text": "Lunr.js ma podobny rozmiar (~8 kB) i wspiera ranking TF-IDF, ale nie ma indeksowania przyrostowego ani auto-suggest. MiniSearch daje add/remove w runtime i wbudowane API autoSuggest.", "tags": ["comparison", "lunr", "alternatives"], "category": "use-cases" },
  { "id": 98, "title": "Porównanie: MiniSearch vs Fuse.js", "text": "Fuse.js (~5 kB) skupia się na fuzzy matching, ale nie jest pełną wyszukiwarką full-text. Brakuje mu prefix search, rankingu TF-IDF i auto-suggest. MiniSearch oferuje pełniejsze doświadczenie wyszukiwania.", "tags": ["comparison", "fuse", "alternatives"], "category": "use-cases" },
  { "id": 99, "title": "Porównanie: MiniSearch vs FlexSearch", "text": "FlexSearch (~6 kB) jest bardzo szybki, ale ma częściowe wsparcie TypeScript i brak wbudowanego auto-suggest. MiniSearch ma natywne TypeScript, auto-suggest i prostsze API.", "tags": ["comparison", "flexsearch", "alternatives"], "category": "use-cases" },
  { "id": 100, "title": "Porównanie: MiniSearch vs Elasticsearch", "text": "Elasticsearch to potężny silnik serwerowy do ogromnych datasetów. MiniSearch jest do wyszukiwania po stronie klienta dla mniejszych zbiorów (do dziesiątek tysięcy dokumentów) bez infrastruktury serwerowej.", "tags": ["comparison", "elasticsearch", "server"], "category": "use-cases" },

  { "id": 101, "title": "Opcje tworzenia indeksu", "text": "Gdy tworzysz nową instancję MiniSearch, obiekt options kontroluje wszystko: które pola indeksować, jak tokenizować, jak przetwarzać terminy, co przechowywać i jakie są domyślne zachowania wyszukiwania.", "tags": ["options", "configuration", "setup"], "category": "api" },
  { "id": 102, "title": "Domyślne opcje wyszukiwania", "text": "Ustaw searchOptions w konstruktorze, aby zastosować domyślne wartości dla każdego wywołania search(). Pojedyncze wywołania search() mogą je nadpisać. Przykład: searchOptions: { prefix: true, fuzzy: 0.2 }.", "tags": ["searchOptions", "defaults", "constructor"], "category": "api" },
  { "id": 103, "title": "Opcje autoSuggest", "text": "autoSuggest() przyjmuje te same opcje co search(), plus: suggest (boolean, domyślnie true). Grupuje pasujące terminy i zwraca je jako podpowiedzi posortowane wg score.", "tags": ["autoSuggest", "options", "grouping"], "category": "api" },
  { "id": 104, "title": "miniSearch.has(id)", "text": "Zwraca true, jeśli dokument o podanym ID jest aktualnie w indeksie. Przydatne do sprawdzenia przed operacjami add/remove.", "tags": ["has", "check", "existence"], "category": "api" },
  { "id": 105, "title": "miniSearch.getStoredFields(id)", "text": "Zwraca przechowywane pola dokumentu po jego ID albo undefined, jeśli dokumentu nie ma w indeksie. Zwraca tylko pola wymienione w storeFields.", "tags": ["getStoredFields", "lookup", "stored"], "category": "api" },

  { "id": 106, "title": "Wzorzec: wyszukiwanie fasetowe", "text": "Połącz wyszukiwanie MiniSearch z agregacją po stronie klienta, aby zbudować fasety. Po wyszukaniu pogrupuj wyniki po polu (np. category) i policz wystąpienia do wyświetlenia liczników.\n\nconst results = ms.search(query);\nconst facets = {};\nresults.forEach(r => { facets[r.category] = (facets[r.category] || 0) + 1; });", "tags": ["facets", "aggregation", "pattern"], "category": "examples" },
  { "id": 107, "title": "Stronicowanie wyników", "text": "MiniSearch zwraca wszystkie pasujące wyniki. Stronicowanie zrobisz, tnąc tablicę wyników:\n\nconst page = 1;\nconst pageSize = 10;\nconst paged = results.slice((page - 1) * pageSize, page * pageSize);", "tags": ["pagination", "slicing", "ui"], "category": "examples" },
  { "id": 108, "title": "Normalizacja score", "text": "Znormalizuj score do zakresu 0–100 do wyświetlania:\n\nconst maxScore = Math.max(...results.map(r => r.score));\nconst normalized = results.map(r => ({ ...r, pct: Math.round(r.score / maxScore * 100) }));", "tags": ["score", "normalization", "display"], "category": "examples" },
  { "id": 109, "title": "Obsługa pustego zapytania", "text": "Gdy zapytanie jest puste, zwróć wszystkie dokumenty lub kuratorowaną listę zamiast wywoływać search(). MiniSearch zwraca pustą tablicę dla pustych zapytań.\n\nif (!query.trim()) { return allDocs; }\nreturn ms.search(query);", "tags": ["empty", "fallback", "edge-case"], "category": "examples" },
  { "id": 110, "title": "Funkcja pomocnicza highlight", "text": "function highlight(text: string, terms: string[]): string {\n  const re = new RegExp(`(${terms.join('|')})`, 'gi');\n  return text.replace(re, '<mark>$1</mark>');\n}\n// Użyj z kluczami result.match, żeby wizualnie podświetlić dopasowania", "tags": ["highlight", "utility", "markup"], "category": "examples" },

  { "id": 111, "title": "Benchmark szybkości indeksowania", "text": "Benchmark: indeksowanie 1 000 dokumentów z 3 polami zajmuje ok. 50–100 ms na nowym sprzęcie. Dla 10 000 dokumentów spodziewaj się ok. 500 ms do 1 s. Dla większych zbiorów rozważ indeksowanie w buildzie.", "tags": ["benchmark", "speed", "indexing"], "category": "concepts" },
  { "id": 112, "title": "Benchmark szybkości wyszukiwania", "text": "Benchmark: wyszukiwanie w 10 000 dokumentów z włączonym prefix i fuzzy zajmuje ok. 2–5 ms. Bez fuzzy wyniki są zwykle poniżej 1 ms. Rzeczywista latencja zależy od złożoności zapytania.", "tags": ["benchmark", "search", "latency"], "category": "concepts" },
  { "id": 113, "title": "Analiza rozmiaru bundla", "text": "MiniSearch dodaje ~7 kB gzipped do bundla. Dla porównania: Fuse.js ~5 kB, Lunr.js ~8 kB, FlexSearch ~6 kB. Wszystkie są wystarczająco małe dla większości aplikacji webowych.", "tags": ["bundle", "size", "gzip"], "category": "concepts" },
  { "id": 114, "title": "Kiedy NIE używać MiniSearch", "text": "MiniSearch nie jest idealny dla: datasetów powyżej 100 000 dokumentów (rozważ silnik serwerowy), wyszukiwania multi-user w czasie rzeczywistym (rozważ bazę danych) albo zapytań geolokalizacyjnych (użyj narzędzia specjalistycznego).", "tags": ["limitations", "alternatives", "scale"], "category": "concepts" },
  { "id": 115, "title": "Unikalność ID dokumentu", "text": "Każdy dokument musi mieć unikalne ID. Dodanie dokumentu z duplikatem ID rzuca błąd. Do aktualizacji użyj discard() + add() albo replace().", "tags": ["id", "unique", "constraint"], "category": "concepts" },

  { "id": 116, "title": "Przykład: filter + boost", "text": "const results = ms.search('javascript', {\n  filter: r => r.category === 'frontend',\n  boost: { title: 3 }\n});\n// Tylko wyniki z frontend, dopasowania w tytule podbite 3x", "tags": ["filter", "boost", "combined"], "category": "examples" },
  { "id": 117, "title": "Dynamiczne liczenie faset", "text": "function getFacetCounts(results: any[], field: string): Record<string, number> {\n  return results.reduce((acc, r) => {\n    acc[r[field]] = (acc[r[field]] || 0) + 1;\n    return acc;\n  }, {} as Record<string, number>);\n}", "tags": ["facets", "dynamic", "utility"], "category": "examples" },
  { "id": 118, "title": "Wyszukiwanie z minimalnym score", "text": "// Odfiltruj wyniki o niskiej trafności\nconst threshold = 1.0;\nconst results = ms.search(query).filter(r => r.score >= threshold);", "tags": ["score", "threshold", "filtering"], "category": "examples" },
  { "id": 119, "title": "Przykład: filtrowanie po tagu", "text": "const results = ms.search('search', {\n  filter: (r) => r.tags?.includes('typescript')\n});\n// Tylko wyniki otagowane 'typescript'", "tags": ["tags", "filter", "array"], "category": "examples" },
  { "id": 120, "title": "Filtr wielu kategorii", "text": "const categories = new Set(['api', 'examples']);\nconst results = ms.search('search', {\n  filter: (r) => categories.has(r.category)\n});\n// Tylko wyniki z 'api' albo 'examples'", "tags": ["filter", "multiple", "set"], "category": "examples" },

  { "id": 121, "title": "Architektura event-driven", "text": "Zbuduj wyszukiwanie event-driven, opakowując MiniSearch w serwis, który emituje zdarzenia przy zmianach indeksu. Komponenty subskrybują wyniki wyszukiwania i renderują się automatycznie.", "tags": ["events", "architecture", "reactive"], "category": "use-cases" },
  { "id": 122, "title": "Wyszukiwanie feature flag", "text": "Zindeksuj feature flagi po nazwie, opisie i właścicielu. Zespoły mogą szybko wyszukiwać flagi podczas debugowania lub audytu bez przewijania długich list.", "tags": ["feature-flags", "devops", "audit"], "category": "use-cases" },
  { "id": 123, "title": "Odkrywanie endpointów API", "text": "Zindeksuj endpointy API wraz ze ścieżkami, metodami i opisami. Developerzy znajdą potrzebny endpoint bez ręcznego przeglądania dokumentacji Swagger/OpenAPI.", "tags": ["api", "discovery", "swagger"], "category": "use-cases" },
  { "id": 124, "title": "Help desk / wyszukiwanie ticketów", "text": "Zindeksuj tickety wsparcia do wyszukiwania po stronie agenta. Fuzzy matching pomaga znaleźć powiązane tickety nawet wtedy, gdy klienci za każdym razem opisują problemy inaczej.", "tags": ["help-desk", "tickets", "support"], "category": "use-cases" },
  { "id": 125, "title": "Współpraca w czasie rzeczywistym", "text": "W edytorach kolaboracyjnych MiniSearch może indeksować współdzielone dokumenty do szybkiego wyszukiwania i nawigacji. Indeksowanie przyrostowe utrzymuje wyszukiwanie w synchronizacji, gdy treść się zmienia.", "tags": ["collaboration", "editor", "realtime"], "category": "use-cases" },

  { "id": 126, "title": "Opcja konstruktora: extractField", "text": "Funkcja (document, fieldName) => string, która wyciąga wartość pola z dokumentu. Przydatne, gdy pola są zagnieżdżone albo wymagają transformacji przed indeksowaniem.", "tags": ["extractField", "nested", "transform"], "category": "api" },
  { "id": 127, "title": "miniSearch.toJSON()", "text": "Zwraca serializowalną reprezentację indeksu. Jest wywoływana pośrednio przez JSON.stringify(). To odpowiednik stanu potrzebnego do odtworzenia przez loadJSON().", "tags": ["toJSON", "serialize", "method"], "category": "api" },
  { "id": 128, "title": "Opcja konstruktora: logger", "text": "Przekaż funkcję logującą (level, message, code), aby dostawać ostrzeżenia o przestarzałych opcjach lub problemach użycia. Przydatne w trakcie developmentu do łapania błędów konfiguracji.", "tags": ["logger", "warnings", "debug"], "category": "api" },

  { "id": 129, "title": "Przykład: ekstrakcja pola zagnieżdżonego", "text": "const ms = new MiniSearch({\n  fields: ['title', 'author.name'],\n  extractField: (doc, field) => {\n    return field.split('.').reduce((obj, key) => obj?.[key], doc);\n  }\n});\n// Indeksuje zagnieżdżone pole 'author.name'", "tags": ["nested", "extractField", "example"], "category": "examples" },
  { "id": 130, "title": "Przykład: indeksowanie pola-tablicy", "text": "const ms = new MiniSearch({\n  fields: ['title', 'tags'],\n  extractField: (doc, field) => {\n    const val = doc[field];\n    return Array.isArray(val) ? val.join(' ') : val;\n  }\n});\n// Łączy pola-tablice w jeden string do indeksowania", "tags": ["array", "extractField", "join"], "category": "examples" },

  { "id": 131, "title": "Wyszukiwanie desktopowe (Electron)", "text": "Użyj MiniSearch w aplikacjach Electron do błyskawicznego wyszukiwania lokalnego w plikach, notatkach lub dowolnej zindeksowanej treści. Brak zależności od sieci oznacza pełny offline.", "tags": ["electron", "desktop", "offline"], "category": "use-cases" },
  { "id": 132, "title": "Wyszukiwanie w rozszerzeniu przeglądarki", "text": "Zbuduj rozszerzenie przeglądarki z MiniSearch, aby przeszukiwać zakładki, historię albo tytuły kart. Mały rozmiar bundla utrzyma rozszerzenie lekkie.", "tags": ["extension", "browser", "lightweight"], "category": "use-cases" },
  { "id": 133, "title": "Wyszukiwanie assetów do gry", "text": "Zindeksuj assety gry (sprite'y, dźwięki, modele 3D) po nazwie, tagach i opisie. Developerzy szybko znajdą zasoby potrzebne podczas tworzenia gry.", "tags": ["games", "assets", "creative"], "category": "use-cases" },
  { "id": 134, "title": "Wyszukiwanie artykułów naukowych", "text": "Zindeksuj tytuły, abstrakty i słowa kluczowe publikacji do szybkiego wyszukiwania literatury. Badacze znajdą relevantne prace bez czekania na wolne zapytania do bazy.", "tags": ["science", "papers", "research"], "category": "use-cases" },
  { "id": 135, "title": "Wyszukiwanie w podcastach / wideo", "text": "Zindeksuj transkrypcje lub metadane podcastów i wideo. Użytkownicy wyszukują tematy wspomniane w odcinkach bez oglądania/słuchania całych materiałów.", "tags": ["podcast", "video", "transcripts"], "category": "use-cases" },

  { "id": 136, "title": "Obsługa błędów: duplikat ID", "text": "MiniSearch rzuca błąd, jeśli spróbujesz add() dokument z ID, które już istnieje w indeksie. Zawsze sprawdzaj has(id) albo użyj replace() do aktualizacji.", "tags": ["error", "duplicate", "safety"], "category": "concepts" },
  { "id": 137, "title": "Obsługa błędów: brakujące pola", "text": "Jeśli dokument nie ma pola wymienionego w tablicy fields w konstruktorze, to pole jest po prostu pomijane podczas indeksowania. Nie ma błędu: dokument jest indeksowany z dostępnymi polami.", "tags": ["error", "missing", "graceful"], "category": "concepts" },
  { "id": 138, "title": "Thread safety (bezpieczeństwo wątków)", "text": "MiniSearch nie jest thread-safe. Jeśli używasz go w web workerze, dopilnuj, aby tylko jeden wątek na raz zapisywał do indeksu. Wiele równoległych wyszukiwań tylko do odczytu jest bezpieczne.", "tags": ["thread", "worker", "concurrency"], "category": "concepts" },
  { "id": 139, "title": "Oczyszczanie (garbage collection)", "text": "Dokumenty odrzucone przez discard() są czyszczone leniwie. Jeśli odrzucasz dużo dokumentów, wywołuj okresowo miniSearch.vacuum(), żeby odzyskać pamięć i utrzymać szybkość wyszukiwania.", "tags": ["vacuum", "gc", "memory"], "category": "api" },
  { "id": 140, "title": "miniSearch.vacuum()", "text": "Czyści indeks, usuwając referencje do odrzuconych dokumentów. Wywołaj po wielu operacjach discard(), aby zoptymalizować zużycie pamięci i wydajność wyszukiwania.", "tags": ["vacuum", "cleanup", "optimize"], "category": "api" },

  { "id": 141, "title": "Wzorzec: asynchroniczne indeksowanie", "text": "// Indeksuj w paczkach, żeby nie blokować głównego wątku\nasync function indexInBatches(ms, docs, batchSize = 100) {\n  for (let i = 0; i < docs.length; i += batchSize) {\n    ms.addAll(docs.slice(i, i + batchSize));\n    await new Promise(r => setTimeout(r, 0));\n  }\n}", "tags": ["async", "batches", "non-blocking"], "category": "examples" },
  { "id": 142, "title": "Mapowanie wyników na pełne dokumenty", "text": "// Zmapuj wyniki z powrotem na pełne dokumenty\nconst docMap = new Map(docs.map(d => [d.id, d]));\nconst results = ms.search(query).map(r => ({\n  ...r,\n  document: docMap.get(r.id)\n}));", "tags": ["mapping", "documents", "lookup"], "category": "examples" },
  { "id": 143, "title": "Tokenizer zależny od locale", "text": "const ms = new MiniSearch({\n  fields: ['text'],\n  tokenize: (text) => {\n    const segmenter = new Intl.Segmenter('ja', { granularity: 'word' });\n    return [...segmenter.segment(text)].filter(s => s.isWordLike).map(s => s.segment);\n  }\n});\n// Segmentacja słów w języku japońskim", "tags": ["locale", "intl", "japanese"], "category": "examples" },

  { "id": 144, "title": "Utrzymanie projektu (governance)", "text": "MiniSearch jest utrzymywany przez Luca Ongaro. Jest wydany na licencji MIT. Projekt ma tysiące gwiazdek na GitHubie i jest aktywnie rozwijany, z regularnymi wydaniami.", "tags": ["license", "mit", "governance"], "category": "concepts" },
  { "id": 145, "title": "Instalacja przez npm", "text": "Zainstaluj MiniSearch przez npm:\n\nnpm install minisearch\n\nAlbo przez yarn:\n\nyarn add minisearch\n\nPaczka zawiera deklaracje TypeScript.", "tags": ["install", "npm", "yarn"], "category": "api" },
  { "id": 146, "title": "Użycie z CDN", "text": "Użyj MiniSearch z CDN bez npm:\n\n<script src=\"https://cdn.jsdelivr.net/npm/minisearch/dist/umd/index.min.js\"></script>\n<script>const ms = new MiniSearch({ fields: ['title'] });</script>", "tags": ["cdn", "script", "no-npm"], "category": "api" },
  { "id": 147, "title": "Import ES module", "text": "import MiniSearch from 'minisearch';\n\n// Nazwane importy dla typów\nimport MiniSearch, { SearchResult, Suggestion } from 'minisearch';", "tags": ["esm", "import", "types"], "category": "api" },

  { "id": 148, "title": "Strategia tagowania", "text": "Zaprojektuj system tagów tak, aby wspierał zarówno szerokie (poziom kategorii), jak i wąskie (konkretny temat) tagi. MiniSearch może przeszukiwać tagi jako pole, co umożliwia mocne kombinacje filtrowania.", "tags": ["strategy", "tags", "design"], "category": "concepts" },
  { "id": 149, "title": "Dobre praktyki projektowania pól", "text": "Trzymaj pola indeksowane w ryzach. Krótkie pole 'title' z wysokim boostem i dłuższe pole 'text' z normalną wagą zwykle daje najlepszy ranking. Unikaj indeksowania bardzo długich pól, jeśli nie musisz.", "tags": ["best-practices", "fields", "design"], "category": "concepts" },
  { "id": 150, "title": "Testowanie jakości wyszukiwania", "text": "Pisz testy oczekiwanego zachowania wyszukiwania: dla zapytania X wynik Y powinien pojawić się w top 3. Automatyczne testy trafności łapią regresje, gdy zmieniasz tokenizację lub boosting.", "tags": ["testing", "quality", "regression"], "category": "concepts" },

  { "id": 151, "title": "Dobre praktyki: debounce", "text": "Używaj debounce 150–300 ms dla inputa wyszukiwania. Za krótki (50 ms) marnuje CPU na pośrednie wyniki. Za długi (500+ ms) sprawia wrażenie ociężałości. 200 ms to dobry default.", "tags": ["debounce", "ux", "performance"], "category": "concepts" },
  { "id": 152, "title": "Dostępność (a11y) w UI wyszukiwarki", "text": "Upewnij się, że input wyszukiwania ma aria-label lub aria-labelledby. Użyj role='search' na formularzu. Ogłaszaj liczbę wyników przez aria-live='polite'. Wspieraj nawigację klawiaturą w liście wyników.", "tags": ["a11y", "aria", "keyboard"], "category": "concepts" },
  { "id": 153, "title": "Wzorzec: stan ładowania", "text": "Pokaż wskaźnik ładowania, gdy indeks się buduje (zwłaszcza dla większych datasetów). Użyj Angular signals lub obserwabli, aby śledzić stan indeksowania i aktualizować UI.", "tags": ["loading", "state", "ux"], "category": "concepts" },
  { "id": 154, "title": "Wzorzec: brak wyników", "text": "Gdy nic nie pasuje, pokaż pomocny stan pusty: zasugeruj sprawdzenie pisowni, użycie szerszych słów lub wyłączenie trybu AND. Nigdy nie pokazuj pustego ekranu.", "tags": ["empty", "no-results", "ux"], "category": "concepts" },
  { "id": 155, "title": "Wzorzec: stan błędu", "text": "Obsługuj błędy budowy indeksu w przyjazny sposób. Jeśli dataset nie wczyta się (błąd sieci, zły JSON), pokaż jasny komunikat i przycisk ponowienia.", "tags": ["error", "retry", "ux"], "category": "concepts" },

  { "id": 156, "title": "Porównanie: MiniSearch vs Algolia", "text": "Algolia to hostowane search-as-a-service z zaawansowanymi funkcjami (AI, analytics, testy A/B). MiniSearch jest samowystarczalny i darmowy, idealny gdy nie potrzebujesz infrastruktury serwerowej ani rozliczeń per-usage.", "tags": ["comparison", "algolia", "hosted"], "category": "use-cases" },
  { "id": 157, "title": "Porównanie: MiniSearch vs Typesense", "text": "Typesense to szybki, open-source serwer wyszukiwania. Wybierz Typesense dla dużych datasetów i infrastruktury serwerowej; wybierz MiniSearch dla wyszukiwania po stronie klienta bez backendu.", "tags": ["comparison", "typesense", "server"], "category": "use-cases" },
  { "id": 158, "title": "Porównanie: MiniSearch vs Meilisearch", "text": "Meilisearch to silnik wyszukiwania w Rust z REST API. Świetnie sprawdza się dla dużych datasetów i scenariuszy multi-tenant. MiniSearch jest prostszy, lżejszy i działa w całości w przeglądarce.", "tags": ["comparison", "meilisearch", "rust"], "category": "use-cases" },
  { "id": 159, "title": "Migracja z Lunr.js", "text": "Migracja z Lunr.js? Kluczowe różnice: MiniSearch wspiera indeksowanie przyrostowe (bez rebuilda), ma wbudowane autoSuggest i pozwala dodawać/usuwać dokumenty w runtime.", "tags": ["migration", "lunr", "upgrade"], "category": "use-cases" },
  { "id": 160, "title": "Migracja z Fuse.js", "text": "Migracja z Fuse.js? MiniSearch dodaje ranking TF-IDF, prefix search i auto-suggest. Zamiast threshold z Fuse użyj parametru fuzzy w MiniSearch, aby kontrolować tolerancję literówek.", "tags": ["migration", "fuse", "upgrade"], "category": "use-cases" },

  { "id": 161, "title": "Wzorzec: analityka wyszukiwania", "text": "Śledź zapytania i liczbę wyników, żeby zrozumieć, czego szukają użytkownicy. Loguj: tekst zapytania, liczbę wyników i czy użytkownik kliknął wynik. Dane wykorzystaj do poprawy treści i trafności.", "tags": ["analytics", "tracking", "improvement"], "category": "concepts" },
  { "id": 162, "title": "Strojenie trafności", "text": "Popraw trafność przez: dostrojenie boostów pól, dodanie synonimów przez processTerm, dopasowanie progów fuzzy i testy na realnych zapytaniach. Iteruj na podstawie analityki wyszukiwania.", "tags": ["relevance", "tuning", "optimization"], "category": "concepts" },
  { "id": 163, "title": "Synonimy przez processTerm", "text": "Synonimy możesz zaimplementować mapując terminy w processTerm:\n\nconst synonyms = { js: 'javascript', ts: 'typescript' };\nprocessTerm: (term) => synonyms[term] || term", "tags": ["synonyms", "processTerm", "mapping"], "category": "examples" },
  { "id": 164, "title": "Usuwanie znaków diakrytycznych", "text": "Usuń znaki diakrytyczne, aby wyszukiwanie nie zależało od akcentów:\n\nprocessTerm: (term) => term.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '').toLowerCase()", "tags": ["accents", "diacritics", "normalization"], "category": "examples" },
  { "id": 165, "title": "Rozbijanie camelCase", "text": "Rozbijaj identyfikatory camelCase, żeby były łatwiejsze do wyszukania:\n\ntokenize: (text) => text.split(/(?=[A-Z])|[\\s_-]+/).map(t => t.toLowerCase()).filter(Boolean)", "tags": ["camelCase", "splitting", "identifiers"], "category": "examples" },

  { "id": 166, "title": "Nawigacja klawiaturą w wynikach", "text": "Zaimplementuj nawigację po wynikach strzałkami. Trzymaj indeks aktywnego elementu, użyj ArrowDown/ArrowUp do zmiany, a Enter do wyboru. Dodaj aria-activedescendant dla czytników ekranu.", "tags": ["keyboard", "navigation", "a11y"], "category": "concepts" },
  { "id": 167, "title": "Skrót do wyszukiwarki (Ctrl+K / Cmd+K)", "text": "Dodaj globalny skrót klawiaturowy, który ustawia fokus na polu wyszukiwania. W wielu aplikacjach standardem jest Ctrl+K (Windows/Linux) lub Cmd+K (Mac), ale czasem warto wybrać inny skrót, żeby uniknąć kolizji z przeglądarką.", "tags": ["shortcut", "keyboard", "focus"], "category": "concepts" },
  { "id": 168, "title": "Generowanie snippetów wyników", "text": "Generuj snippety zależne od kontekstu: znajdź dopasowany termin w pełnym tekście i wytnij otaczające go słowa. Pokaż 20–30 słów wokół dopasowania z wielokropkiem.", "tags": ["snippets", "context", "display"], "category": "concepts" },
  { "id": 169, "title": "Wirtualizowana lista wyników", "text": "Dla dużych list wyników użyj virtual scroll, żeby renderować tylko widoczne elementy. Biblioteki typu @angular/cdk virtual scroll dobrze integrują się z wynikami MiniSearch.", "tags": ["virtual-scroll", "performance", "cdk"], "category": "concepts" },
  { "id": 170, "title": "Responsywny layout wyszukiwania", "text": "Na mobile wyniki powinny układać się pionowo z większymi celami dotyku. Na desktop rozważ panel boczny albo modal. Użyj media queries w CSS, aby zapewnić responsywność.", "tags": ["responsive", "mobile", "layout"], "category": "concepts" },

  { "id": 171, "title": "UI podpowiedzi z nawigacją kursorem", "text": "const suggestions = ms.autoSuggest(query, { prefix: true });\n// Renderuj jako dropdown pod inputem\n// Podświetl dopasowany prefiks w każdej sugestii\n// Nawiguj strzałkami, wybieraj Enter", "tags": ["suggestions", "dropdown", "ui"], "category": "examples" },
  { "id": 172, "title": "Wyszukiwanie z zakresem dat", "text": "const results = ms.search(query, {\n  filter: (r) => {\n    const d = new Date(r.date);\n    return d >= startDate && d <= endDate;\n  }\n});\n// Połącz wyszukiwanie tekstowe z filtrowaniem po dacie", "tags": ["date", "range", "filter"], "category": "examples" },
  { "id": 173, "title": "Wyszukiwanie na wielu indeksach", "text": "// Szukaj w wielu indeksach i scalaj wyniki\nconst r1 = index1.search(query);\nconst r2 = index2.search(query);\nconst merged = [...r1, ...r2].sort((a, b) => b.score - a.score);", "tags": ["multi-index", "merge", "advanced"], "category": "examples" },
  { "id": 174, "title": "Cache wyników wyszukiwania", "text": "const cache = new Map();\nfunction cachedSearch(query) {\n  if (!cache.has(query)) {\n    cache.set(query, ms.search(query));\n  }\n  return cache.get(query);\n}\n// Wyczyść cache, gdy indeks się zmienia", "tags": ["caching", "performance", "map"], "category": "examples" },
  { "id": 175, "title": "Progresywne ulepszanie wyszukiwania", "text": "Zacznij od prostego dopasowania stringów, a potem stopniowo włączaj: prefix search → fuzzy search → boosting pól → filtrowanie. Każdy poziom dodaje złożoność, ale poprawia doświadczenie wyszukiwania.", "tags": ["progressive", "enhancement", "strategy"], "category": "concepts" },

  { "id": 176, "title": "Wyszukiwanie w task runnerze", "text": "Zindeksuj skrypty npm, cele Makefile lub kroki pipeline CI. Developerzy szybko znajdą komendę, której potrzebują, bez pamiętania dokładnych nazw i bez czytania dokumentacji.", "tags": ["tasks", "scripts", "devops"], "category": "use-cases" },
  { "id": 177, "title": "Wyszukiwarka konfiguracji", "text": "Zindeksuj klucze konfiguracyjne w plikach .env, YAML i ustawieniach JSON. Zespół znajdzie, gdzie dana opcja jest zdefiniowana, bez grepowania przez dziesiątki plików.", "tags": ["config", "settings", "search"], "category": "use-cases" },
  { "id": 178, "title": "Wyszukiwanie w bibliotece komponentów", "text": "Zbuduj przeszukiwalną bibliotekę komponentów/storybooka. Indeksuj nazwy komponentów, opisy, propsy i przykłady użycia. Projektanci i developerzy znajdą komponenty natychmiast.", "tags": ["components", "storybook", "design-system"], "category": "use-cases" },
  { "id": 179, "title": "Wyszukiwanie w notatkach ze spotkań", "text": "Zindeksuj notatki ze spotkań, action items i decyzje. Członkowie zespołu wyszukają wcześniejsze ustalenia bez przewijania tygodni notatek.", "tags": ["meetings", "notes", "team"], "category": "use-cases" },
  { "id": 180, "title": "Wyszukiwanie w changelogu", "text": "Zindeksuj wpisy changelogu po wersji, dacie i opisie. Użytkownicy i developerzy szybko sprawdzą, kiedy dodano feature albo naprawiono błąd.", "tags": ["changelog", "versions", "history"], "category": "use-cases" },

  { "id": 181, "title": "Przykład: fuzzy warunkowe", "text": "// Włącz fuzzy tylko dla dłuższych terminów\nconst results = ms.search('anglar', {\n  fuzzy: (term, i, terms) => term.length > 3 ? 0.2 : false\n});\n// Krótkie terminy używają exact match, dłuższe dopuszczają literówki", "tags": ["fuzzy", "conditional", "advanced"], "category": "examples" },
  { "id": 182, "title": "Przykład: boost po świeżości (recency)", "text": "// Podbij nowsze dokumenty, łącząc score z datą\nconst results = ms.search(query).map(r => ({\n  ...r,\n  adjustedScore: r.score * (1 + 1 / (Date.now() - new Date(r.date).getTime()))\n})).sort((a, b) => b.adjustedScore - a.adjustedScore);", "tags": ["boost", "recency", "date"], "category": "examples" },
  { "id": 183, "title": "Przykład: filtr negatywny", "text": "// Wyklucz określone kategorie\nconst results = ms.search(query, {\n  filter: (r) => r.category !== 'archived'\n});\n// Wszystko poza kategorią 'archived'", "tags": ["filter", "exclude", "negative"], "category": "examples" },
  { "id": 184, "title": "Przykład: wyszukiwanie z fallbackiem", "text": "// Najpierw spróbuj ścisłego AND, a jeśli brak wyników, przejdź na OR\nlet results = ms.search(query, { combineWith: 'AND' });\nif (results.length === 0) {\n  results = ms.search(query, { combineWith: 'OR' });\n}", "tags": ["fallback", "AND", "OR"], "category": "examples" },
  { "id": 185, "title": "Wzorzec: top-N wyników", "text": "// Weź tylko top 5 wyników\nconst top5 = ms.search(query).slice(0, 5);\n// Przydatne do dropdownu podpowiedzi albo paneli podglądu", "tags": ["top-n", "limit", "slice"], "category": "examples" },

  { "id": 186, "title": "Strategia: rozgrzanie indeksu (warm-up)", "text": "Dla lepszego UX buduj indeks wyszukiwania jak najszybciej, gdy dataset jest dostępny (np. przy starcie aplikacji lub route resolve). Dzięki temu indeks jest gotowy, zanim użytkownik zacznie pisać.", "tags": ["warm-up", "preload", "strategy"], "category": "concepts" },
  { "id": 187, "title": "Częściowe aktualizacje indeksu", "text": "Gdy zmienia się tylko kilka dokumentów, użyj replace() zamiast przebudowy całego indeksu. To dużo szybsze i nie powoduje widocznej przerwy w UI.", "tags": ["partial", "update", "efficiency"], "category": "concepts" },
  { "id": 188, "title": "Antywzorce UX wyszukiwania", "text": "Unikaj: automatycznego wyszukiwania na każdy klawisz bez debounce, pokazywania surowych score użytkownikom, wymagania idealnie dokładnych zapytań, chowania pola wyszukiwania albo braku obsługi stanu pustego.", "tags": ["anti-patterns", "ux", "avoid"], "category": "concepts" },
  { "id": 189, "title": "Szacowanie rozmiaru indeksu", "text": "Reguła kciuka: indeks w pamięci zajmuje ok. 2–5x rozmiar źródłowego tekstu. Dla 1 MB tekstu spodziewaj się 2–5 MB użycia pamięci. Największym kosztem są stringi.", "tags": ["memory", "estimation", "planning"], "category": "concepts" },
  { "id": 190, "title": "Kiedy fuzzy, a kiedy prefix", "text": "Używaj prefix do autouzupełniania (użytkownik nadal pisze). Używaj fuzzy do gotowych zapytań z możliwymi literówkami. Możesz połączyć oba tryby dla maksymalnej elastyczności, ale licz się z nieco większą liczbą wyników.", "tags": ["fuzzy", "prefix", "decision"], "category": "concepts" },

  { "id": 191, "title": "Przykład: warunkowy prefix", "text": "// Włącz prefix tylko dla ostatniego terminu (typeahead)\nconst results = ms.search(query, {\n  prefix: (term, i, terms) => i === terms.length - 1\n});\n// Wcześniejsze terminy muszą pasować dokładnie", "tags": ["prefix", "conditional", "typeahead"], "category": "examples" },
  { "id": 192, "title": "Przykład: input z przyciskiem czyszczenia", "text": "// Fragment template Angular\n// <input [(ngModel)]='query' />\n// <button *ngIf='query' (click)='query = \"\"'>Wyczyść</button>\n// Zawsze daj możliwość wyczyszczenia pola wyszukiwania", "tags": ["clear", "input", "ux"], "category": "examples" },
  { "id": 193, "title": "Wyświetlanie liczby wyników", "text": "// Pokaż liczbę wyników i czas wyszukiwania\nconst start = performance.now();\nconst results = ms.search(query);\nconst time = (performance.now() - start).toFixed(1);\nconsole.log(`${results.length} wyników w ${time} ms`);", "tags": ["count", "timing", "display"], "category": "examples" },
  { "id": 194, "title": "Lazy loading datasetu", "text": "// Wczytaj dataset dopiero, gdy strona wyszukiwania jest używana\nasync function loadAndIndex() {\n  const res = await fetch('/minisearch-docs.json');\n  const docs = await res.json();\n  ms.addAll(docs);\n}", "tags": ["lazy", "fetch", "load"], "category": "examples" },
  { "id": 195, "title": "Przebudowa indeksu po zmianie danych", "text": "// Gdy dane źródłowe się zmienią, przebuduj indeks\nfunction rebuildIndex(docs) {\n  const ms = new MiniSearch({ fields: ['title', 'text'] });\n  ms.addAll(docs);\n  return ms;\n}\n// Podmień starą instancję na nową", "tags": ["rebuild", "data-change", "fresh"], "category": "examples" },

  { "id": 196, "title": "Uwagi dot. SSR", "text": "MiniSearch działa w każdym środowisku JS, także przy server-side rendering. Możesz zbudować indeks po stronie serwera i przenieść go do klienta przez loadJSON(), aby był dostępny natychmiast.", "tags": ["ssr", "server-rendering", "transfer"], "category": "concepts" },
  { "id": 197, "title": "Testowanie w Vitest", "text": "import { describe, it, expect } from 'vitest';\nimport MiniSearch from 'minisearch';\n\ndescribe('Search', () => {\n  it('finds documents by title', () => {\n    const ms = new MiniSearch({ fields: ['title'] });\n    ms.addAll([{ id: 1, title: 'Angular' }]);\n    expect(ms.search('angular')).toHaveLength(1);\n  });\n});", "tags": ["vitest", "testing", "unit"], "category": "examples" },
  { "id": 198, "title": "Pomiar wydajności", "text": "function measureSearch(ms, query, runs = 20) {\n  const times = [];\n  for (let i = 0; i < runs; i++) {\n    const start = performance.now();\n    ms.search(query);\n    times.push(performance.now() - start);\n  }\n  times.sort((a, b) => a - b);\n  return { median: times[Math.floor(runs/2)], p95: times[Math.floor(runs*0.95)] };\n}", "tags": ["performance", "benchmark", "measurement"], "category": "examples" },
  { "id": 199, "title": "Strategia wersjonowania", "text": "MiniSearch używa semantic versioning. Duże wersje (major) mogą zawierać breaking changes w API. Przed upgrade sprawdź changelog. Mniejsze wersje (minor) dodają funkcje, a patch naprawia błędy.", "tags": ["versioning", "semver", "changelog"], "category": "concepts" },
  { "id": 200, "title": "Społeczność i wsparcie", "text": "MiniSearch ma aktywne repozytorium na GitHubie z issue, dyskusjami i pull requestami. Dokumentacja opisuje metody API z przykładami. Stack Overflow też ma odpowiedzi na częste pytania.", "tags": ["community", "support", "github"], "category": "concepts" }
]
